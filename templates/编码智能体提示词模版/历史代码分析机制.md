# ğŸ”„ å†å²ä»£ç è¯»å–å’Œä¿®æ”¹æœºåˆ¶è®¾è®¡

## ğŸ¯ è®¾è®¡ç›®æ ‡

ç¼–ç æ™ºèƒ½ä½“åº”è¯¥èƒ½å¤Ÿï¼š
1. **è¯»å–å†å²ä»£ç ** - åˆ†æç°æœ‰Gitåˆ†æ”¯çš„ä»£ç ç»“æ„å’ŒåŠŸèƒ½
2. **ç†è§£ä»£ç è¯­ä¹‰** - è§£æä»£ç é€»è¾‘ã€ä¾èµ–å…³ç³»ã€æ¶æ„æ¨¡å¼
3. **å¢é‡ä¿®æ”¹** - åœ¨ç°æœ‰ä»£ç åŸºç¡€ä¸Šè¿›è¡Œç²¾ç¡®ä¿®æ”¹å’Œæ‰©å±•
4. **ä¿æŒä¸€è‡´æ€§** - ç¡®ä¿ä¿®æ”¹åçš„ä»£ç é£æ ¼å’Œæ¶æ„ä¸€è‡´
5. **ç‰ˆæœ¬ç®¡ç†** - è·Ÿè¸ªå˜æ›´å†å²ï¼Œæ”¯æŒå›æ»šå’Œåˆå¹¶

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„

### å†å²ä»£ç å¤„ç†æµç¨‹
```
ğŸ”„ å†å²ä»£ç å¤„ç†æµç¨‹:
â”œâ”€â”€ ä»£ç å‘ç° (Code Discovery)
â”‚   â”œâ”€â”€ Gitåˆ†æ”¯æ‰«æ
â”‚   â”œâ”€â”€ ä»£ç æ–‡ä»¶è¯†åˆ«  
â”‚   â””â”€â”€ é¡¹ç›®ç»“æ„åˆ†æ
â”œâ”€â”€ ä»£ç åˆ†æ (Code Analysis)
â”‚   â”œâ”€â”€ ASTè§£æ
â”‚   â”œâ”€â”€ ä¾èµ–å…³ç³»åˆ†æ
â”‚   â”œâ”€â”€ æ¶æ„æ¨¡å¼è¯†åˆ«
â”‚   â””â”€â”€ ä»£ç è´¨é‡è¯„ä¼°
â”œâ”€â”€ è¯­ä¹‰ç†è§£ (Semantic Understanding)
â”‚   â”œâ”€â”€ åŠŸèƒ½æ¨¡å—è¯†åˆ«
â”‚   â”œâ”€â”€ ä¸šåŠ¡é€»è¾‘æå–
â”‚   â”œâ”€â”€ æ¥å£å¥‘çº¦åˆ†æ
â”‚   â””â”€â”€ æ•°æ®æµåˆ†æ
â”œâ”€â”€ ä¿®æ”¹ç­–ç•¥ (Modification Strategy)
â”‚   â”œâ”€â”€ å˜æ›´ç‚¹è¯†åˆ«
â”‚   â”œâ”€â”€ å½±å“èŒƒå›´åˆ†æ
â”‚   â”œâ”€â”€ ä¿®æ”¹æ–¹æ¡ˆç”Ÿæˆ
â”‚   â””â”€â”€ å…¼å®¹æ€§æ£€æŸ¥
â””â”€â”€ ä»£ç ç”Ÿæˆ (Code Generation)
    â”œâ”€â”€ å¢é‡ä»£ç ç”Ÿæˆ
    â”œâ”€â”€ ç°æœ‰ä»£ç ä¿®æ”¹
    â”œâ”€â”€ æ–°æ–‡ä»¶åˆ›å»º
    â””â”€â”€ é…ç½®æ›´æ–°
```

## ğŸ“Š æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. å†å²ä»£ç å‘ç°å™¨ï¼ˆCode Discoveryï¼‰
```python
# src/corder_integration/code_analysis/code_discovery.py

import os
import git
from typing import Dict, List, Any, Optional
from pathlib import Path

class CodeDiscovery:
    """ä»£ç å‘ç°å™¨"""
    
    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path)
        self.repo = git.Repo(repo_path)
    
    async def discover_project_structure(self, branch_name: str = "main") -> Dict[str, Any]:
        """å‘ç°é¡¹ç›®ç»“æ„"""
        # åˆ‡æ¢åˆ°æŒ‡å®šåˆ†æ”¯
        self.repo.git.checkout(branch_name)
        
        project_structure = {
            "branch": branch_name,
            "commit_hash": self.repo.head.commit.hexsha,
            "services": {},
            "shared_modules": {},
            "configuration": {}
        }
        
        # æ‰«æé¡¹ç›®ç›®å½•
        for root, dirs, files in os.walk(self.repo_path):
            relative_path = Path(root).relative_to(self.repo_path)
            
            # è¯†åˆ«å¾®æœåŠ¡ç›®å½•
            if self._is_service_directory(root, dirs, files):
                service_name = self._extract_service_name(relative_path)
                project_structure["services"][service_name] = await self._analyze_service_structure(root)
        
        return project_structure
    
    def _is_service_directory(self, root: str, dirs: List[str], files: List[str]) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¾®æœåŠ¡ç›®å½•"""
        # SpringBootå¾®æœåŠ¡ç‰¹å¾
        springboot_indicators = [
            "src/main/java",
            "pom.xml", 
            "application.yml"
        ]
        
        for indicator in springboot_indicators:
            if os.path.exists(os.path.join(root, indicator)):
                return True
        
        return False
    
    async def _analyze_service_structure(self, service_path: str) -> Dict[str, Any]:
        """åˆ†ææœåŠ¡ç»“æ„"""
        structure = {
            "path": service_path,
            "type": "microservice",
            "source_files": {},
            "dependencies": [],
            "apis": []
        }
        
        # æ‰«ææºä»£ç æ–‡ä»¶
        src_path = os.path.join(service_path, "src")
        if os.path.exists(src_path):
            structure["source_files"] = await self._scan_source_files(src_path)
        
        return structure
    
    async def _scan_source_files(self, src_path: str) -> Dict[str, List[str]]:
        """æ‰«ææºä»£ç æ–‡ä»¶"""
        source_files = {
            "controllers": [],
            "services": [],
            "repositories": [],
            "entities": [],
            "dtos": [],
            "configs": []
        }
        
        for root, dirs, files in os.walk(src_path):
            for file in files:
                if file.endswith('.java'):
                    file_path = os.path.join(root, file)
                    relative_path = os.path.relpath(file_path, src_path)
                    
                    # æ ¹æ®æ–‡ä»¶è·¯å¾„å’Œåç§°åˆ†ç±»
                    if 'controller' in file.lower():
                        source_files["controllers"].append(relative_path)
                    elif 'service' in file.lower():
                        source_files["services"].append(relative_path)
                    elif 'repository' in file.lower():
                        source_files["repositories"].append(relative_path)
                    elif 'entity' in file.lower():
                        source_files["entities"].append(relative_path)
        
        return source_files
```

### 2. ä»£ç è¯­ä¹‰åˆ†æå™¨ï¼ˆSemantic Analyzerï¼‰
```python
# src/corder_integration/code_analysis/semantic_analyzer.py

import javalang
from typing import Dict, List, Any

class SemanticAnalyzer:
    """ä»£ç è¯­ä¹‰åˆ†æå™¨"""
    
    def __init__(self):
        self.java_parser = javalang
    
    async def analyze_service_semantics(self, service_path: str, source_files: Dict[str, List[str]]) -> Dict[str, Any]:
        """åˆ†ææœåŠ¡è¯­ä¹‰"""
        semantics = {
            "business_domain": "",
            "core_entities": [],
            "business_operations": [],
            "api_contracts": [],
            "design_patterns": []
        }
        
        # åˆ†æå®ä½“ç±»
        for entity_file in source_files.get("entities", []):
            entity_path = os.path.join(service_path, "src", entity_file)
            entity_info = await self._analyze_entity_class(entity_path)
            semantics["core_entities"].append(entity_info)
        
        # åˆ†æä¸šåŠ¡æœåŠ¡
        for service_file in source_files.get("services", []):
            service_path_full = os.path.join(service_path, "src", service_file)
            service_info = await self._analyze_service_class(service_path_full)
            semantics["business_operations"].extend(service_info["operations"])
        
        # åˆ†ææ§åˆ¶å™¨
        for controller_file in source_files.get("controllers", []):
            controller_path = os.path.join(service_path, "src", controller_file)
            controller_info = await self._analyze_controller_class(controller_path)
            semantics["api_contracts"].extend(controller_info["apis"])
        
        return semantics
    
    async def _analyze_entity_class(self, entity_path: str) -> Dict[str, Any]:
        """åˆ†æå®ä½“ç±»"""
        try:
            with open(entity_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            tree = javalang.parse.parse(content)
            
            entity_info = {
                "name": "",
                "attributes": [],
                "relationships": []
            }
            
            # æŸ¥æ‰¾ç±»å®šä¹‰
            for path, node in tree.filter(javalang.tree.ClassDeclaration):
                entity_info["name"] = node.name
                
                # åˆ†æå­—æ®µ
                for field_path, field_node in node.filter(javalang.tree.FieldDeclaration):
                    for declarator in field_node.declarators:
                        entity_info["attributes"].append({
                            "name": declarator.name,
                            "type": field_node.type.name if hasattr(field_node.type, 'name') else str(field_node.type)
                        })
            
            return entity_info
            
        except Exception as e:
            return {"name": Path(entity_path).stem, "error": str(e)}
    
    async def _analyze_service_class(self, service_path: str) -> Dict[str, Any]:
        """åˆ†ææœåŠ¡ç±»"""
        try:
            with open(service_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            tree = javalang.parse.parse(content)
            
            service_info = {
                "name": "",
                "operations": []
            }
            
            # æŸ¥æ‰¾ç±»å®šä¹‰
            for path, node in tree.filter(javalang.tree.ClassDeclaration):
                service_info["name"] = node.name
                
                # åˆ†ææ–¹æ³•
                for method_path, method_node in node.filter(javalang.tree.MethodDeclaration):
                    operation = {
                        "name": method_node.name,
                        "parameters": [],
                        "return_type": method_node.return_type.name if method_node.return_type else "void"
                    }
                    
                    # åˆ†æå‚æ•°
                    if method_node.parameters:
                        for param in method_node.parameters:
                            operation["parameters"].append({
                                "name": param.name,
                                "type": param.type.name if hasattr(param.type, 'name') else str(param.type)
                            })
                    
                    service_info["operations"].append(operation)
            
            return service_info
            
        except Exception as e:
            return {"name": Path(service_path).stem, "error": str(e)}
    
    async def _analyze_controller_class(self, controller_path: str) -> Dict[str, Any]:
        """åˆ†ææ§åˆ¶å™¨ç±»"""
        try:
            with open(controller_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            tree = javalang.parse.parse(content)
            
            controller_info = {
                "name": "",
                "apis": []
            }
            
            # æŸ¥æ‰¾ç±»å®šä¹‰
            for path, node in tree.filter(javalang.tree.ClassDeclaration):
                controller_info["name"] = node.name
                
                # åˆ†æAPIæ–¹æ³•
                for method_path, method_node in node.filter(javalang.tree.MethodDeclaration):
                    api_info = {
                        "name": method_node.name,
                        "parameters": [],
                        "return_type": method_node.return_type.name if method_node.return_type else "void"
                    }
                    
                    controller_info["apis"].append(api_info)
            
            return controller_info
            
        except Exception as e:
            return {"name": Path(controller_path).stem, "error": str(e)}
```

### 3. å¢é‡ä¿®æ”¹å¼•æ“ï¼ˆIncremental Modifierï¼‰
```python
# src/corder_integration/code_modification/incremental_modifier.py

from typing import Dict, List, Any

class IncrementalModifier:
    """å¢é‡ä¿®æ”¹å¼•æ“"""
    
    def __init__(self):
        pass
    
    async def generate_modification_plan(self, 
                                       current_code: Dict[str, Any],
                                       requirements: Dict[str, Any],
                                       existing_semantics: Dict[str, Any]) -> Dict[str, Any]:
        """ç”Ÿæˆä¿®æ”¹è®¡åˆ’"""
        
        modification_plan = {
            "target_service": requirements.get("service_name"),
            "modifications": [],
            "new_files": []
        }
        
        # åˆ†æéœ€è¦çš„ä¿®æ”¹
        required_changes = await self._analyze_required_changes(requirements, existing_semantics)
        
        # ä¸ºæ¯ä¸ªå˜æ›´ç”Ÿæˆå…·ä½“çš„ä¿®æ”¹æ“ä½œ
        for change in required_changes:
            modification = await self._generate_modification(change, current_code)
            modification_plan["modifications"].append(modification)
        
        return modification_plan
    
    async def _analyze_required_changes(self, requirements: Dict[str, Any], 
                                      existing_semantics: Dict[str, Any]) -> List[Dict[str, Any]]:
        """åˆ†æéœ€è¦çš„å˜æ›´"""
        changes = []
        
        # åˆ†ææ–°å¢çš„APIéœ€æ±‚
        required_apis = requirements.get("apis", [])
        existing_apis = [api["name"] for api in existing_semantics.get("api_contracts", [])]
        
        for api in required_apis:
            if api["name"] not in existing_apis:
                changes.append({
                    "type": "add_api",
                    "target": "controller", 
                    "details": api
                })
        
        # åˆ†ææ–°å¢çš„ä¸šåŠ¡é€»è¾‘éœ€æ±‚
        required_operations = requirements.get("business_operations", [])
        existing_operations = [op["name"] for op in existing_semantics.get("business_operations", [])]
        
        for operation in required_operations:
            if operation["name"] not in existing_operations:
                changes.append({
                    "type": "add_business_operation",
                    "target": "service",
                    "details": operation
                })
        
        return changes
    
    async def _generate_modification(self, change: Dict[str, Any], 
                                   current_code: Dict[str, Any]) -> Dict[str, Any]:
        """ç”Ÿæˆå…·ä½“çš„ä¿®æ”¹æ“ä½œ"""
        
        modification = {
            "change_type": change["type"],
            "target_file": "",
            "operations": []
        }
        
        if change["type"] == "add_api":
            modification = await self._generate_api_addition(change, current_code)
        elif change["type"] == "add_business_operation":
            modification = await self._generate_business_operation_addition(change, current_code)
        
        return modification
    
    async def _generate_api_addition(self, change: Dict[str, Any], 
                                   current_code: Dict[str, Any]) -> Dict[str, Any]:
        """ç”ŸæˆAPIæ·»åŠ çš„ä¿®æ”¹"""
        api_details = change["details"]
        
        # æ‰¾åˆ°ç›®æ ‡æ§åˆ¶å™¨æ–‡ä»¶
        controllers = current_code.get("source_files", {}).get("controllers", [])
        target_controller = controllers[0] if controllers else "UserController.java"
        
        # ç”ŸæˆAPIæ–¹æ³•ä»£ç 
        method_code = self._generate_api_method_code(api_details)
        
        modification = {
            "change_type": "add_api",
            "target_file": target_controller,
            "operations": [
                {
                    "type": "add_method",
                    "content": method_code
                }
            ]
        }
        
        return modification
    
    def _generate_api_method_code(self, api_details: Dict[str, Any]) -> str:
        """ç”ŸæˆAPIæ–¹æ³•ä»£ç """
        method_name = api_details["name"]
        http_method = api_details.get("http_method", "GET")
        path = api_details.get("path", f"/{method_name}")
        
        method_body = f"""
    @{http_method}Mapping("{path}")
    public ResponseEntity<String> {method_name}() {{
        // TODO: å®ç°ä¸šåŠ¡é€»è¾‘
        return ResponseEntity.ok("success");
    }}
"""
        
        return method_body
    
    async def apply_modifications(self, modification_plan: Dict[str, Any], 
                                service_path: str) -> Dict[str, Any]:
        """åº”ç”¨ä¿®æ”¹è®¡åˆ’"""
        
        application_result = {
            "success": True,
            "applied_changes": [],
            "failed_changes": []
        }
        
        for modification in modification_plan["modifications"]:
            try:
                # åº”ç”¨ä¿®æ”¹
                target_file = os.path.join(service_path, modification["target_file"])
                modified_content = await self._apply_single_modification(modification, target_file)
                
                # å†™å…¥ä¿®æ”¹åçš„æ–‡ä»¶
                with open(target_file, 'w', encoding='utf-8') as f:
                    f.write(modified_content)
                
                application_result["applied_changes"].append({
                    "file": target_file,
                    "success": True
                })
                
            except Exception as e:
                application_result["failed_changes"].append({
                    "file": modification["target_file"],
                    "error": str(e)
                })
                application_result["success"] = False
        
        return application_result
    
    async def _apply_single_modification(self, modification: Dict[str, Any], 
                                       target_file: str) -> str:
        """åº”ç”¨å•ä¸ªä¿®æ”¹"""
        
        # è¯»å–åŸæ–‡ä»¶å†…å®¹
        with open(target_file, 'r', encoding='utf-8') as f:
            original_content = f.read()
        
        modified_content = original_content
        
        # åº”ç”¨æ‰€æœ‰æ“ä½œ
        for operation in modification["operations"]:
            if operation["type"] == "add_method":
                modified_content = self._add_method_to_class(modified_content, operation["content"])
        
        return modified_content
    
    def _add_method_to_class(self, content: str, method_code: str) -> str:
        """å‘ç±»ä¸­æ·»åŠ æ–¹æ³•"""
        # æ‰¾åˆ°ç±»çš„ç»“æŸä½ç½®ï¼ˆæœ€åä¸€ä¸ª}ï¼‰
        lines = content.split('\n')
        
        # ä»åå¾€å‰æ‰¾åˆ°ç±»çš„ç»“æŸ}
        for i in range(len(lines) - 1, -1, -1):
            line = lines[i].strip()
            if line == '}' and i > 0:
                # åœ¨}ä¹‹å‰æ’å…¥æ–°æ–¹æ³•
                lines.insert(i, method_code)
                break
        
        return '\n'.join(lines)
```

### 4. é›†æˆåˆ°æ™ºèƒ½ç¼–ç èŠ‚ç‚¹
```python
# åœ¨ intelligent_coding_node.py ä¸­é›†æˆå†å²ä»£ç åˆ†æ

async def intelligent_coding_node(state: CodingAgentState) -> CodingAgentState:
    """æ™ºèƒ½ç¼–ç èŠ‚ç‚¹ - æ”¯æŒå†å²ä»£ç åˆ†æå’Œä¿®æ”¹"""
    
    # ğŸ” 1. å‘ç°å’Œåˆ†æç°æœ‰ä»£ç 
    for service_name in state["identified_services"]:
        service_path = state["project_paths"][service_name]
        
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨ç°æœ‰ä»£ç 
        if os.path.exists(service_path) and os.listdir(service_path):
            # ç°æœ‰æœåŠ¡ï¼šè¿›è¡Œå¢é‡ä¿®æ”¹
            discovery = CodeDiscovery(service_path)
            existing_structure = await discovery.discover_project_structure(state["target_branch"])
            
            # è¯­ä¹‰åˆ†æ
            semantic_analyzer = SemanticAnalyzer()
            existing_semantics = await semantic_analyzer.analyze_service_semantics(
                service_path, 
                existing_structure["services"][service_name]["source_files"]
            )
            
            # ç”Ÿæˆä¿®æ”¹è®¡åˆ’
            modifier = IncrementalModifier()
            requirements = state["service_requirements"][service_name]
            
            modification_plan = await modifier.generate_modification_plan(
                existing_structure["services"][service_name],
                requirements,
                existing_semantics
            )
            
            # åº”ç”¨ä¿®æ”¹
            application_result = await modifier.apply_modifications(
                modification_plan, service_path
            )
            
            # å­˜å‚¨ç»“æœ
            state["generated_services"][service_name] = {
                "type": "incremental_modification",
                "existing_code": existing_structure,
                "modification_plan": modification_plan,
                "application_result": application_result
            }
        else:
            # æ–°æœåŠ¡ï¼šä»å¤´ç”Ÿæˆ
            generated_code = await generate_new_service(service_name, state)
            state["generated_services"][service_name] = {
                "type": "new_service",
                "generated_code": generated_code
            }
    
    state["current_phase"] = "code_review"
    return state
```

## ğŸ¯ ä½¿ç”¨ç¤ºä¾‹

### åœºæ™¯ï¼šåœ¨ç°æœ‰ç”¨æˆ·æœåŠ¡åŸºç¡€ä¸Šæ·»åŠ æ–°åŠŸèƒ½

```python
async def example_incremental_modification():
    """ç¤ºä¾‹ï¼šå¢é‡ä¿®æ”¹ç°æœ‰ç”¨æˆ·æœåŠ¡"""
    
    # 1. å‘ç°ç°æœ‰ä»£ç 
    discovery = CodeDiscovery("/path/to/user-service")
    existing_structure = await discovery.discover_project_structure("main")
    
    # 2. åˆ†æç°æœ‰è¯­ä¹‰
    analyzer = SemanticAnalyzer()
    existing_semantics = await analyzer.analyze_service_semantics(
        existing_structure["services"]["user-service"]["path"],
        existing_structure["services"]["user-service"]["source_files"]
    )
    
    # 3. å®šä¹‰æ–°éœ€æ±‚
    requirements = {
        "service_name": "user-service",
        "apis": [
            {
                "name": "updateUserProfile",
                "http_method": "PUT", 
                "path": "/users/{id}/profile"
            }
        ]
    }
    
    # 4. ç”Ÿæˆå’Œåº”ç”¨ä¿®æ”¹
    modifier = IncrementalModifier()
    modification_plan = await modifier.generate_modification_plan(
        existing_structure["services"]["user-service"],
        requirements,
        existing_semantics
    )
    
    result = await modifier.apply_modifications(
        modification_plan,
        existing_structure["services"]["user-service"]["path"]
    )
    
    print(f"ä¿®æ”¹ç»“æœ: {result}")
```

## ğŸ“Š æ ¸å¿ƒç‰¹æ€§æ€»ç»“

### ğŸ” å†å²ä»£ç åˆ†æèƒ½åŠ›
1. **é¡¹ç›®ç»“æ„å‘ç°** - è‡ªåŠ¨è¯†åˆ«å¾®æœåŠ¡ã€å…±äº«æ¨¡å—ã€é…ç½®æ–‡ä»¶
2. **ä»£ç è¯­ä¹‰åˆ†æ** - æ·±åº¦ç†è§£ä¸šåŠ¡é€»è¾‘ã€æ•°æ®æ¨¡å‹ã€APIæ¥å£
3. **æ¶æ„æ¨¡å¼è¯†åˆ«** - è¯†åˆ«ç°æœ‰çš„è®¾è®¡æ¨¡å¼å’Œæ¶æ„é£æ ¼
4. **ä¾èµ–å…³ç³»åˆ†æ** - åˆ†ææœåŠ¡é—´ä¾èµ–å’Œæ•°æ®æµ

### ğŸ”„ å¢é‡ä¿®æ”¹èƒ½åŠ›
1. **ç²¾ç¡®ä¿®æ”¹** - åœ¨ç°æœ‰ä»£ç åŸºç¡€ä¸Šè¿›è¡Œæœ€å°åŒ–ä¿®æ”¹
2. **æ™ºèƒ½æ’å…¥** - è‡ªåŠ¨è¯†åˆ«æœ€ä½³æ’å…¥ä½ç½®
3. **ä¸€è‡´æ€§ä¿æŒ** - ç¡®ä¿ä¿®æ”¹åçš„ä»£ç é£æ ¼å’Œæ¶æ„ä¸€è‡´
4. **å½±å“åˆ†æ** - åˆ†æä¿®æ”¹å¯¹å…¶ä»–æ¨¡å—çš„å½±å“

### ğŸ“ ä»£ç è´¨é‡ä¿è¯
1. **å·®å¼‚å¯¹æ¯”** - ç”Ÿæˆè¯¦ç»†çš„ä»£ç å˜æ›´æŠ¥å‘Š
2. **ä¸€è‡´æ€§æ£€æŸ¥** - å¤šç»´åº¦æ£€æŸ¥ä»£ç ä¸€è‡´æ€§
3. **è‡ªåŠ¨ä¿®å¤** - æä¾›è‡ªåŠ¨ä¿®å¤å»ºè®®
4. **å›æ»šæ”¯æŒ** - æ”¯æŒä¿®æ”¹å›æ»šå’Œç‰ˆæœ¬ç®¡ç†

è¿™ä¸ªå†å²ä»£ç è¯»å–å’Œä¿®æ”¹æœºåˆ¶å°†è®©ç¼–ç æ™ºèƒ½ä½“å…·å¤‡çœŸæ­£çš„"ä»£ç ç†è§£"å’Œ"å¢é‡å¼€å‘"èƒ½åŠ›ï¼Œå®ç°æ›´æ™ºèƒ½çš„ä»£ç ç”Ÿæˆï¼ 