# 🧠 上下文记忆系统详细设计

## 🎯 记忆系统架构概览

上下文记忆系统是编码智能体的"大脑"，负责存储、检索和应用历史经验。

### 记忆层次结构
```
🧠 记忆层次结构:
├── 工作记忆 (Working Memory) - 当前任务上下文
├── 短期记忆 (Short-term Memory) - 项目级别记忆  
├── 长期记忆 (Long-term Memory) - 跨项目持久化
└── 知识图谱 (Knowledge Graph) - 关系型知识

📊 记忆类型:
├── 任务记忆 (Task Memory) - 任务拆分经验
├── 代码记忆 (Code Memory) - 代码模式和模板
├── 模式记忆 (Pattern Memory) - 架构模式
├── 项目记忆 (Project Memory) - 项目特定知识
└── 错误记忆 (Error Memory) - 错误处理经验
```

## 📚 记忆分层设计

### 1. 工作记忆（Working Memory）
```python
# src/corder_integration/memory/working_memory.py
"""
工作记忆：当前任务执行中的临时信息
- 生命周期：单次任务执行期间
- 存储：内存 + Redis缓存
- 容量：有限容量（50个项目）
"""

from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class WorkingMemoryItem:
    memory_id: str
    memory_type: str  # context/instruction/result/error
    content: Dict[str, Any]
    importance: float  # 0-1重要性评分
    timestamp: datetime
    access_count: int = 0

class WorkingMemory:
    """工作记忆管理器"""
    
    def __init__(self, max_items: int = 50):
        self.max_items = max_items
        self.memory_items: Dict[str, WorkingMemoryItem] = {}
    
    async def store_context(self, context_type: str, content: Dict[str, Any]) -> str:
        """存储上下文信息"""
        memory_id = f"{context_type}_{datetime.now().timestamp()}"
        
        # 计算重要性评分
        importance = self._calculate_importance(context_type, content)
        
        item = WorkingMemoryItem(
            memory_id=memory_id,
            memory_type=context_type,
            content=content,
            importance=importance,
            timestamp=datetime.now()
        )
        
        self.memory_items[memory_id] = item
        
        # 容量管理
        if len(self.memory_items) > self.max_items:
            await self._evict_low_importance_items()
        
        return memory_id
    
    async def get_relevant_context(self, query: str) -> List[Dict[str, Any]]:
        """获取相关上下文"""
        relevant_items = []
        
        for item in self.memory_items.values():
            relevance = self._calculate_relevance(query, item.content)
            if relevance > 0.3:  # 相关度阈值
                relevant_items.append({
                    "content": item.content,
                    "relevance": relevance,
                    "importance": item.importance,
                    "timestamp": item.timestamp
                })
        
        # 按相关度和重要性排序
        relevant_items.sort(key=lambda x: x["relevance"] * x["importance"], reverse=True)
        return relevant_items[:10]  # 返回前10个最相关的
    
    def _calculate_importance(self, context_type: str, content: Dict[str, Any]) -> float:
        """计算重要性评分"""
        base_scores = {
            "task_result": 0.8,
            "error": 0.9,
            "success_pattern": 0.7,
            "user_feedback": 0.8,
            "intermediate_result": 0.4
        }
        
        base_score = base_scores.get(context_type, 0.5)
        
        # 根据内容调整评分
        if "error" in content:
            base_score += 0.1
        if "success" in content and content["success"]:
            base_score += 0.1
        
        return min(base_score, 1.0)
```

### 2. 短期记忆（Short-term Memory）
```python
# src/corder_integration/memory/short_term_memory.py
"""
短期记忆：项目执行期间的记忆
- 生命周期：整个项目执行期间
- 存储：Redis + 部分MySQL
- 容量：按项目分区
"""

import redis
import json
from typing import Dict, List, Any

class ShortTermMemory:
    """短期记忆管理器"""
    
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=1)
        self.memory_prefix = "short_term_memory"
    
    async def store_project_context(self, project_id: str, context: Dict[str, Any]):
        """存储项目上下文"""
        key = f"{self.memory_prefix}:project:{project_id}"
        self.redis_client.setex(key, 86400, json.dumps(context))  # 24小时TTL
    
    async def store_task_history(self, task_id: str, task_data: Dict[str, Any]):
        """存储任务历史"""
        key = f"{self.memory_prefix}:task:{task_id}"
        self.redis_client.setex(key, 86400, json.dumps(task_data))
        
        # 添加到任务索引
        index_key = f"{self.memory_prefix}:task_index"
        self.redis_client.sadd(index_key, task_id)
    
    async def get_similar_tasks(self, current_task: Dict[str, Any]) -> List[Dict[str, Any]]:
        """获取相似任务"""
        index_key = f"{self.memory_prefix}:task_index"
        task_ids = self.redis_client.smembers(index_key)
        
        similar_tasks = []
        for task_id in task_ids:
            task_key = f"{self.memory_prefix}:task:{task_id}"
            task_data = self.redis_client.get(task_key)
            if task_data:
                task_info = json.loads(task_data)
                similarity = self._calculate_task_similarity(current_task, task_info)
                if similarity > 0.6:
                    similar_tasks.append({
                        "task_id": task_id,
                        "task_data": task_info,
                        "similarity": similarity
                    })
        
        return sorted(similar_tasks, key=lambda x: x["similarity"], reverse=True)
```

### 3. 长期记忆（Long-term Memory）
```python
# src/corder_integration/memory/long_term_memory.py
"""
长期记忆：跨项目的持久化记忆
- 生命周期：永久存储
- 存储：MySQL + 向量数据库
- 功能：代码模式、项目模板、错误解决方案
"""

from typing import Dict, List, Any
import mysql.connector
from sentence_transformers import SentenceTransformer

class LongTermMemory:
    """长期记忆管理器"""
    
    def __init__(self, mysql_connection):
        self.mysql = mysql_connection
        self.encoder = SentenceTransformer('all-MiniLM-L6-v2')
        self._init_tables()
    
    def _init_tables(self):
        """初始化长期记忆表"""
        cursor = self.mysql.cursor()
        
        # 代码模式表
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS code_patterns (
                pattern_id VARCHAR(255) PRIMARY KEY,
                pattern_type VARCHAR(100),
                description TEXT,
                code_template TEXT,
                usage_count INT DEFAULT 0,
                success_rate FLOAT DEFAULT 0.0,
                tags JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # 项目模板表
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS project_templates (
                template_id VARCHAR(255) PRIMARY KEY,
                project_type VARCHAR(100),
                tech_stack JSON,
                structure_template JSON,
                usage_count INT DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # 错误解决方案表
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS error_solutions (
                solution_id VARCHAR(255) PRIMARY KEY,
                error_type VARCHAR(100),
                error_pattern TEXT,
                solution_description TEXT,
                solution_code TEXT,
                success_count INT DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        self.mysql.commit()
    
    async def store_code_pattern(self, pattern: Dict[str, Any]) -> str:
        """存储代码模式"""
        cursor = self.mysql.cursor()
        
        pattern_id = f"pattern_{datetime.now().timestamp()}"
        
        cursor.execute("""
            INSERT INTO code_patterns 
            (pattern_id, pattern_type, description, code_template, tags)
            VALUES (%s, %s, %s, %s, %s)
        """, (
            pattern_id,
            pattern["type"],
            pattern["description"],
            pattern["code_template"],
            json.dumps(pattern.get("tags", []))
        ))
        
        self.mysql.commit()
        return pattern_id
    
    async def retrieve_similar_patterns(self, description: str, limit: int = 5) -> List[Dict[str, Any]]:
        """检索相似代码模式"""
        cursor = self.mysql.cursor()
        
        # 简单的文本相似度搜索
        cursor.execute("""
            SELECT * FROM code_patterns 
            WHERE description LIKE %s
            ORDER BY usage_count DESC, success_rate DESC
            LIMIT %s
        """, (f"%{description}%", limit))
        
        patterns = []
        for row in cursor.fetchall():
            patterns.append({
                "pattern_id": row[0],
                "pattern_type": row[1],
                "description": row[2],
                "code_template": row[3],
                "usage_count": row[4],
                "success_rate": row[5],
                "tags": json.loads(row[6] or "[]")
            })
        
        return patterns
    
    async def learn_from_success(self, pattern_id: str):
        """从成功中学习"""
        cursor = self.mysql.cursor()
        cursor.execute("""
            UPDATE code_patterns 
            SET usage_count = usage_count + 1,
                success_rate = (success_rate * usage_count + 1.0) / (usage_count + 1)
            WHERE pattern_id = %s
        """, (pattern_id,))
        self.mysql.commit()
```

### 4. 知识图谱（Knowledge Graph）
```python
# src/corder_integration/memory/knowledge_graph.py
"""
知识图谱：关系型知识存储
- 存储：简化版本使用MySQL，复杂版本使用Neo4j
- 功能：服务关系、依赖关系、架构模式
"""

class KnowledgeGraph:
    """知识图谱管理器"""
    
    def __init__(self, mysql_connection):
        self.mysql = mysql_connection
        self._init_tables()
    
    def _init_tables(self):
        """初始化知识图谱表"""
        cursor = self.mysql.cursor()
        
        # 服务关系表
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS service_relationships (
                id INT AUTO_INCREMENT PRIMARY KEY,
                source_service VARCHAR(255),
                target_service VARCHAR(255),
                relationship_type VARCHAR(100),
                properties JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # 架构模式表
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS architecture_patterns (
                pattern_id VARCHAR(255) PRIMARY KEY,
                pattern_name VARCHAR(255),
                services JSON,
                relationships JSON,
                usage_count INT DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        self.mysql.commit()
    
    async def add_service_relationship(self, source: str, target: str, 
                                     rel_type: str, properties: Dict[str, Any]):
        """添加服务关系"""
        cursor = self.mysql.cursor()
        cursor.execute("""
            INSERT INTO service_relationships 
            (source_service, target_service, relationship_type, properties)
            VALUES (%s, %s, %s, %s)
        """, (source, target, rel_type, json.dumps(properties)))
        self.mysql.commit()
    
    async def get_service_dependencies(self, service_name: str) -> List[Dict[str, Any]]:
        """获取服务依赖"""
        cursor = self.mysql.cursor()
        cursor.execute("""
            SELECT target_service, relationship_type, properties
            FROM service_relationships
            WHERE source_service = %s
        """, (service_name,))
        
        dependencies = []
        for row in cursor.fetchall():
            dependencies.append({
                "dependency": row[0],
                "relationship_type": row[1],
                "properties": json.loads(row[2] or "{}")
            })
        
        return dependencies
```

## 🔍 记忆检索引擎

```python
# src/corder_integration/memory/memory_retrieval_engine.py
"""
记忆检索引擎：智能检索相关记忆
"""

class MemoryRetrievalEngine:
    """记忆检索引擎"""
    
    def __init__(self):
        self.working_memory = WorkingMemory()
        self.short_term_memory = ShortTermMemory()
        self.long_term_memory = LongTermMemory()
        self.knowledge_graph = KnowledgeGraph()
    
    async def retrieve_coding_context(self, task_description: str) -> Dict[str, Any]:
        """检索编码任务的上下文"""
        context = {}
        
        # 1. 获取工作记忆中的相关上下文
        context["current_context"] = await self.working_memory.get_relevant_context(task_description)
        
        # 2. 获取相似的历史任务
        context["similar_tasks"] = await self.short_term_memory.get_similar_tasks({
            "description": task_description,
            "type": "coding"
        })
        
        # 3. 获取相关的代码模式
        context["code_patterns"] = await self.long_term_memory.retrieve_similar_patterns(
            task_description, limit=3
        )
        
        # 4. 获取架构关系
        if "service" in task_description.lower():
            service_name = self._extract_service_name(task_description)
            context["dependencies"] = await self.knowledge_graph.get_service_dependencies(service_name)
        
        return context
    
    async def adaptive_retrieval(self, task_context: Dict[str, Any]) -> Dict[str, Any]:
        """自适应检索：根据任务特征智能选择记忆策略"""
        task_type = task_context.get("type", "unknown")
        complexity = task_context.get("complexity", 0.5)
        
        if task_type == "coding":
            return await self._retrieve_coding_memories(task_context, complexity)
        elif task_type == "testing":
            return await self._retrieve_testing_memories(task_context, complexity)
        elif task_type == "review":
            return await self._retrieve_review_memories(task_context, complexity)
        else:
            return await self.retrieve_coding_context(str(task_context))
    
    async def _retrieve_coding_memories(self, task_context: Dict[str, Any], complexity: float):
        """检索编码相关记忆"""
        memories = {}
        
        # 高复杂度任务需要更多历史经验
        pattern_limit = 5 if complexity > 0.7 else 3
        
        memories["patterns"] = await self.long_term_memory.retrieve_similar_patterns(
            task_context.get("description", ""), limit=pattern_limit
        )
        
        # 获取相关的项目模板
        if "project_type" in task_context:
            memories["templates"] = await self.long_term_memory.get_project_templates(
                task_context["project_type"]
            )
        
        return memories
```

## 🎯 记忆管理器集成

```python
# src/corder_integration/memory/memory_manager.py
"""
记忆管理器：统一的记忆管理接口
"""

class MemoryManager:
    """统一记忆管理器"""
    
    def __init__(self):
        self.working_memory = WorkingMemory()
        self.short_term_memory = ShortTermMemory()
        self.long_term_memory = LongTermMemory()
        self.knowledge_graph = KnowledgeGraph()
        self.retrieval_engine = MemoryRetrievalEngine()
    
    async def store_context(self, context_type: str, content: Dict[str, Any], 
                          persistence_level: str = "working") -> str:
        """存储上下文"""
        if persistence_level == "working":
            return await self.working_memory.store_context(context_type, content)
        elif persistence_level == "short_term":
            return await self.short_term_memory.store_project_context(
                content.get("project_id", "default"), content
            )
        elif persistence_level == "long_term":
            return await self.long_term_memory.store_code_pattern(content)
        
    async def retrieve_context(self, query: str, context_type: str = "coding") -> Dict[str, Any]:
        """检索上下文"""
        if context_type == "coding":
            return await self.retrieval_engine.retrieve_coding_context(query)
        elif context_type == "adaptive":
            return await self.retrieval_engine.adaptive_retrieval({"description": query})
        else:
            return await self.retrieval_engine.retrieve_coding_context(query)
    
    async def learn_from_experience(self, experience: Dict[str, Any]):
        """从经验中学习"""
        # 存储成功的代码模式
        if experience.get("success") and "code_pattern" in experience:
            await self.long_term_memory.store_code_pattern(experience["code_pattern"])
        
        # 更新模式成功率
        if "pattern_id" in experience:
            if experience.get("success"):
                await self.long_term_memory.learn_from_success(experience["pattern_id"])
        
        # 存储服务关系
        if "service_relationship" in experience:
            rel = experience["service_relationship"]
            await self.knowledge_graph.add_service_relationship(
                rel["source"], rel["target"], rel["type"], rel.get("properties", {})
            )
```

## 💡 记忆系统使用示例

```python
# 在智能体中使用记忆系统
class CodingAgentWithMemory:
    """带记忆的编码智能体"""
    
    def __init__(self):
        self.memory_manager = MemoryManager()
    
    async def execute_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """执行任务"""
        
        # 1. 检索相关上下文
        context = await self.memory_manager.retrieve_context(
            task["description"], 
            context_type="adaptive"
        )
        
        # 2. 使用上下文执行任务
        result = await self._execute_with_context(task, context)
        
        # 3. 存储执行结果
        await self.memory_manager.store_context(
            "task_result", 
            {
                "task_id": task["id"],
                "result": result,
                "success": result.get("success", False)
            },
            persistence_level="working"
        )
        
        # 4. 从经验中学习
        if result.get("success"):
            await self.memory_manager.learn_from_experience({
                "success": True,
                "task_type": task["type"],
                "code_pattern": result.get("pattern_used")
            })
        
        return result
    
    async def _execute_with_context(self, task: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """使用上下文执行任务"""
        # 利用历史模式和经验
        patterns = context.get("patterns", [])
        similar_tasks = context.get("similar_tasks", [])
        
        # 选择最佳模式
        best_pattern = self._select_best_pattern(patterns, task)
        
        # 生成代码
        code = await self._generate_code_with_pattern(task, best_pattern)
        
        return {
            "code": code,
            "pattern_used": best_pattern,
            "success": True
        }
```

## 📊 记忆系统特性总结

### 核心特性
1. **分层记忆架构** - 工作记忆、短期记忆、长期记忆、知识图谱
2. **智能检索** - 语义搜索、相似度匹配、上下文感知
3. **自适应学习** - 从成功和失败中学习，动态调整
4. **关系建模** - 服务依赖、架构模式的图谱存储
5. **上下文感知** - 根据任务类型和复杂度调整记忆策略

### 技术实现
- **存储**: 内存 + Redis + MySQL + (可选)向量数据库
- **检索**: 文本匹配 + 语义搜索 + 图谱查询
- **学习**: 成功率统计 + 模式提取 + 关系更新

这个记忆系统将让编码智能体具备真正的"记忆"和"学习"能力！ 