# ğŸ”„ å†å²ä»£ç è¯»å–å’Œä¿®æ”¹æœºåˆ¶è®¾è®¡

## ğŸ¯ è®¾è®¡ç›®æ ‡

ç¼–ç æ™ºèƒ½ä½“åº”è¯¥èƒ½å¤Ÿï¼š
1. **è¯»å–å†å²ä»£ç ** - åˆ†æç°æœ‰Gitåˆ†æ”¯çš„ä»£ç ç»“æ„å’ŒåŠŸèƒ½
2. **ç†è§£ä»£ç è¯­ä¹‰** - è§£æä»£ç é€»è¾‘ã€ä¾èµ–å…³ç³»ã€æ¶æ„æ¨¡å¼
3. **å¢é‡ä¿®æ”¹** - åœ¨ç°æœ‰ä»£ç åŸºç¡€ä¸Šè¿›è¡Œç²¾ç¡®ä¿®æ”¹å’Œæ‰©å±•
4. **ä¿æŒä¸€è‡´æ€§** - ç¡®ä¿ä¿®æ”¹åçš„ä»£ç é£æ ¼å’Œæ¶æ„ä¸€è‡´
5. **ç‰ˆæœ¬ç®¡ç†** - è·Ÿè¸ªå˜æ›´å†å²ï¼Œæ”¯æŒå›æ»šå’Œåˆå¹¶

## ğŸ—ï¸ æ¶æ„è®¾è®¡

```
ğŸ”„ å†å²ä»£ç å¤„ç†æµç¨‹:
â”œâ”€â”€ ä»£ç å‘ç° (Code Discovery)
â”‚   â”œâ”€â”€ Gitåˆ†æ”¯æ‰«æ
â”‚   â”œâ”€â”€ ä»£ç æ–‡ä»¶è¯†åˆ«
â”‚   â””â”€â”€ é¡¹ç›®ç»“æ„åˆ†æ
â”œâ”€â”€ ä»£ç åˆ†æ (Code Analysis)
â”‚   â”œâ”€â”€ ASTè§£æ
â”‚   â”œâ”€â”€ ä¾èµ–å…³ç³»åˆ†æ
â”‚   â”œâ”€â”€ æ¶æ„æ¨¡å¼è¯†åˆ«
â”‚   â””â”€â”€ ä»£ç è´¨é‡è¯„ä¼°
â”œâ”€â”€ è¯­ä¹‰ç†è§£ (Semantic Understanding)
â”‚   â”œâ”€â”€ åŠŸèƒ½æ¨¡å—è¯†åˆ«
â”‚   â”œâ”€â”€ ä¸šåŠ¡é€»è¾‘æå–
â”‚   â”œâ”€â”€ æ¥å£å¥‘çº¦åˆ†æ
â”‚   â””â”€â”€ æ•°æ®æµåˆ†æ
â”œâ”€â”€ ä¿®æ”¹ç­–ç•¥ (Modification Strategy)
â”‚   â”œâ”€â”€ å˜æ›´ç‚¹è¯†åˆ«
â”‚   â”œâ”€â”€ å½±å“èŒƒå›´åˆ†æ
â”‚   â”œâ”€â”€ ä¿®æ”¹æ–¹æ¡ˆç”Ÿæˆ
â”‚   â””â”€â”€ å…¼å®¹æ€§æ£€æŸ¥
â””â”€â”€ ä»£ç ç”Ÿæˆ (Code Generation)
    â”œâ”€â”€ å¢é‡ä»£ç ç”Ÿæˆ
    â”œâ”€â”€ ç°æœ‰ä»£ç ä¿®æ”¹
    â”œâ”€â”€ æ–°æ–‡ä»¶åˆ›å»º
    â””â”€â”€ é…ç½®æ›´æ–°
```

## ğŸ“Š æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. å†å²ä»£ç å‘ç°å™¨ï¼ˆCode Discoveryï¼‰
```python
# src/corder_integration/code_analysis/code_discovery.py
"""
å†å²ä»£ç å‘ç°å™¨ï¼šæ‰«æå’Œè¯†åˆ«ç°æœ‰ä»£ç ç»“æ„
"""

import os
import git
from typing import Dict, List, Any, Optional
from pathlib import Path
import fnmatch

class CodeDiscovery:
    """ä»£ç å‘ç°å™¨"""
    
    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path)
        self.repo = git.Repo(repo_path)
        self.supported_languages = {
            "java": ["*.java"],
            "python": ["*.py"],
            "javascript": ["*.js", "*.ts"],
            "yaml": ["*.yml", "*.yaml"],
            "xml": ["*.xml"],
            "properties": ["*.properties"]
        }
    
    async def discover_project_structure(self, branch_name: str = "main") -> Dict[str, Any]:
        """å‘ç°é¡¹ç›®ç»“æ„"""
        # åˆ‡æ¢åˆ°æŒ‡å®šåˆ†æ”¯
        self.repo.git.checkout(branch_name)
        
        project_structure = {
            "branch": branch_name,
            "commit_hash": self.repo.head.commit.hexsha,
            "services": {},
            "shared_modules": {},
            "configuration": {},
            "documentation": {},
            "tests": {}
        }
        
        # æ‰«æé¡¹ç›®ç›®å½•
        for root, dirs, files in os.walk(self.repo_path):
            relative_path = Path(root).relative_to(self.repo_path)
            
            # è¯†åˆ«å¾®æœåŠ¡ç›®å½•
            if self._is_service_directory(root, dirs, files):
                service_name = self._extract_service_name(relative_path)
                project_structure["services"][service_name] = await self._analyze_service_structure(root)
            
            # è¯†åˆ«å…±äº«æ¨¡å—
            elif self._is_shared_module(root, dirs, files):
                module_name = relative_path.name
                project_structure["shared_modules"][module_name] = await self._analyze_module_structure(root)
            
            # è¯†åˆ«é…ç½®æ–‡ä»¶
            elif self._is_configuration_directory(root, files):
                project_structure["configuration"].update(await self._analyze_configuration(root))
        
        return project_structure
    
    def _is_service_directory(self, root: str, dirs: List[str], files: List[str]) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¾®æœåŠ¡ç›®å½•"""
        # SpringBootå¾®æœåŠ¡ç‰¹å¾
        springboot_indicators = [
            "src/main/java",
            "pom.xml",
            "application.yml",
            "application.properties"
        ]
        
        for indicator in springboot_indicators:
            if os.path.exists(os.path.join(root, indicator)):
                return True
        
        # æ£€æŸ¥æ˜¯å¦æœ‰Javaæºä»£ç 
        java_files = [f for f in files if f.endswith('.java')]
        if java_files and 'src' in dirs:
            return True
        
        return False
    
    async def _analyze_service_structure(self, service_path: str) -> Dict[str, Any]:
        """åˆ†ææœåŠ¡ç»“æ„"""
        structure = {
            "path": service_path,
            "type": "microservice",
            "technology": await self._identify_technology_stack(service_path),
            "source_files": {},
            "resources": {},
            "dependencies": [],
            "apis": [],
            "database": {}
        }
        
        # æ‰«ææºä»£ç æ–‡ä»¶
        src_path = os.path.join(service_path, "src")
        if os.path.exists(src_path):
            structure["source_files"] = await self._scan_source_files(src_path)
        
        # åˆ†æä¾èµ–
        pom_path = os.path.join(service_path, "pom.xml")
        if os.path.exists(pom_path):
            structure["dependencies"] = await self._analyze_maven_dependencies(pom_path)
        
        # åˆ†æAPIæ¥å£
        structure["apis"] = await self._extract_api_definitions(structure["source_files"])
        
        return structure
    
    async def _scan_source_files(self, src_path: str) -> Dict[str, List[str]]:
        """æ‰«ææºä»£ç æ–‡ä»¶"""
        source_files = {
            "controllers": [],
            "services": [],
            "repositories": [],
            "entities": [],
            "dtos": [],
            "configs": [],
            "utils": []
        }
        
        for root, dirs, files in os.walk(src_path):
            for file in files:
                if file.endswith('.java'):
                    file_path = os.path.join(root, file)
                    relative_path = os.path.relpath(file_path, src_path)
                    
                    # æ ¹æ®æ–‡ä»¶è·¯å¾„å’Œåç§°åˆ†ç±»
                    if 'controller' in file.lower() or 'controller' in root.lower():
                        source_files["controllers"].append(relative_path)
                    elif 'service' in file.lower() or 'service' in root.lower():
                        source_files["services"].append(relative_path)
                    elif 'repository' in file.lower() or 'repository' in root.lower():
                        source_files["repositories"].append(relative_path)
                    elif 'entity' in file.lower() or 'entity' in root.lower():
                        source_files["entities"].append(relative_path)
                    elif 'dto' in file.lower() or 'dto' in root.lower():
                        source_files["dtos"].append(relative_path)
                    elif 'config' in file.lower() or 'config' in root.lower():
                        source_files["configs"].append(relative_path)
                    else:
                        source_files["utils"].append(relative_path)
        
        return source_files
    
    async def get_branch_history(self, branch_name: str, max_commits: int = 10) -> List[Dict[str, Any]]:
        """è·å–åˆ†æ”¯å†å²"""
        try:
            self.repo.git.checkout(branch_name)
            commits = list(self.repo.iter_commits(branch_name, max_count=max_commits))
            
            history = []
            for commit in commits:
                history.append({
                    "hash": commit.hexsha,
                    "message": commit.message.strip(),
                    "author": str(commit.author),
                    "date": commit.committed_datetime.isoformat(),
                    "changed_files": [item.a_path for item in commit.stats.files.keys()]
                })
            
            return history
        except Exception as e:
            return []
```

### 2. ä»£ç è¯­ä¹‰åˆ†æå™¨ï¼ˆSemantic Analyzerï¼‰
```python
# src/corder_integration/code_analysis/semantic_analyzer.py
"""
ä»£ç è¯­ä¹‰åˆ†æå™¨ï¼šæ·±åº¦ç†è§£ä»£ç ç»“æ„å’ŒåŠŸèƒ½
"""

import ast
import javalang
from typing import Dict, List, Any, Optional
from pathlib import Path

class SemanticAnalyzer:
    """ä»£ç è¯­ä¹‰åˆ†æå™¨"""
    
    def __init__(self):
        self.java_parser = javalang
        self.analysis_cache = {}
    
    async def analyze_service_semantics(self, service_path: str, source_files: Dict[str, List[str]]) -> Dict[str, Any]:
        """åˆ†ææœåŠ¡è¯­ä¹‰"""
        semantics = {
            "business_domain": "",
            "core_entities": [],
            "business_operations": [],
            "data_flow": [],
            "external_dependencies": [],
            "api_contracts": [],
            "design_patterns": [],
            "architecture_style": ""
        }
        
        # åˆ†æå®ä½“ç±»
        for entity_file in source_files.get("entities", []):
            entity_path = os.path.join(service_path, "src", entity_file)
            entity_info = await self._analyze_entity_class(entity_path)
            semantics["core_entities"].append(entity_info)
        
        # åˆ†æä¸šåŠ¡æœåŠ¡
        for service_file in source_files.get("services", []):
            service_path_full = os.path.join(service_path, "src", service_file)
            service_info = await self._analyze_service_class(service_path_full)
            semantics["business_operations"].extend(service_info["operations"])
        
        # åˆ†ææ§åˆ¶å™¨
        for controller_file in source_files.get("controllers", []):
            controller_path = os.path.join(service_path, "src", controller_file)
            controller_info = await self._analyze_controller_class(controller_path)
            semantics["api_contracts"].extend(controller_info["apis"])
        
        # æ¨æ–­ä¸šåŠ¡é¢†åŸŸ
        semantics["business_domain"] = self._infer_business_domain(semantics)
        
        # è¯†åˆ«æ¶æ„æ¨¡å¼
        semantics["design_patterns"] = self._identify_design_patterns(source_files)
        
        return semantics
    
    async def _analyze_entity_class(self, entity_path: str) -> Dict[str, Any]:
        """åˆ†æå®ä½“ç±»"""
        try:
            with open(entity_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # è§£æJavaä»£ç 
            tree = javalang.parse.parse(content)
            
            entity_info = {
                "name": "",
                "attributes": [],
                "relationships": [],
                "annotations": [],
                "business_meaning": ""
            }
            
            # æŸ¥æ‰¾ç±»å®šä¹‰
            for path, node in tree.filter(javalang.tree.ClassDeclaration):
                entity_info["name"] = node.name
                entity_info["annotations"] = [ann.name for ann in node.annotations] if node.annotations else []
                
                # åˆ†æå­—æ®µ
                for field_path, field_node in node.filter(javalang.tree.FieldDeclaration):
                    for declarator in field_node.declarators:
                        entity_info["attributes"].append({
                            "name": declarator.name,
                            "type": field_node.type.name if hasattr(field_node.type, 'name') else str(field_node.type),
                            "annotations": [ann.name for ann in field_node.annotations] if field_node.annotations else []
                        })
                
                # åˆ†æå…³ç³»ï¼ˆåŸºäºJPAæ³¨è§£ï¼‰
                entity_info["relationships"] = self._extract_jpa_relationships(node)
            
            # æ¨æ–­ä¸šåŠ¡å«ä¹‰
            entity_info["business_meaning"] = self._infer_entity_business_meaning(entity_info)
            
            return entity_info
            
        except Exception as e:
            return {"name": Path(entity_path).stem, "error": str(e)}
    
    async def _analyze_service_class(self, service_path: str) -> Dict[str, Any]:
        """åˆ†ææœåŠ¡ç±»"""
        try:
            with open(service_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            tree = javalang.parse.parse(content)
            
            service_info = {
                "name": "",
                "operations": [],
                "dependencies": [],
                "annotations": [],
                "business_logic": []
            }
            
            # æŸ¥æ‰¾ç±»å®šä¹‰
            for path, node in tree.filter(javalang.tree.ClassDeclaration):
                service_info["name"] = node.name
                service_info["annotations"] = [ann.name for ann in node.annotations] if node.annotations else []
                
                # åˆ†ææ–¹æ³•
                for method_path, method_node in node.filter(javalang.tree.MethodDeclaration):
                    operation = {
                        "name": method_node.name,
                        "parameters": [],
                        "return_type": method_node.return_type.name if method_node.return_type else "void",
                        "annotations": [ann.name for ann in method_node.annotations] if method_node.annotations else [],
                        "business_logic": self._extract_business_logic(method_node)
                    }
                    
                    # åˆ†æå‚æ•°
                    if method_node.parameters:
                        for param in method_node.parameters:
                            operation["parameters"].append({
                                "name": param.name,
                                "type": param.type.name if hasattr(param.type, 'name') else str(param.type)
                            })
                    
                    service_info["operations"].append(operation)
                
                # åˆ†æä¾èµ–æ³¨å…¥
                service_info["dependencies"] = self._extract_dependencies(node)
            
            return service_info
            
        except Exception as e:
            return {"name": Path(service_path).stem, "error": str(e)}
    
    async def _analyze_controller_class(self, controller_path: str) -> Dict[str, Any]:
        """åˆ†ææ§åˆ¶å™¨ç±»"""
        try:
            with open(controller_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            tree = javalang.parse.parse(content)
            
            controller_info = {
                "name": "",
                "base_path": "",
                "apis": [],
                "annotations": []
            }
            
            # æŸ¥æ‰¾ç±»å®šä¹‰
            for path, node in tree.filter(javalang.tree.ClassDeclaration):
                controller_info["name"] = node.name
                controller_info["annotations"] = [ann.name for ann in node.annotations] if node.annotations else []
                
                # æå–RequestMappingè·¯å¾„
                controller_info["base_path"] = self._extract_request_mapping(node.annotations)
                
                # åˆ†æAPIæ–¹æ³•
                for method_path, method_node in node.filter(javalang.tree.MethodDeclaration):
                    api_info = {
                        "name": method_node.name,
                        "path": self._extract_request_mapping(method_node.annotations),
                        "http_method": self._extract_http_method(method_node.annotations),
                        "parameters": [],
                        "return_type": method_node.return_type.name if method_node.return_type else "void",
                        "description": self._extract_api_description(method_node)
                    }
                    
                    # åˆ†æå‚æ•°
                    if method_node.parameters:
                        for param in method_node.parameters:
                            api_info["parameters"].append({
                                "name": param.name,
                                "type": param.type.name if hasattr(param.type, 'name') else str(param.type),
                                "annotations": [ann.name for ann in param.annotations] if param.annotations else []
                            })
                    
                    controller_info["apis"].append(api_info)
            
            return controller_info
            
        except Exception as e:
            return {"name": Path(controller_path).stem, "error": str(e)}
    
    def _infer_business_domain(self, semantics: Dict[str, Any]) -> str:
        """æ¨æ–­ä¸šåŠ¡é¢†åŸŸ"""
        # åŸºäºå®ä½“åç§°å’Œæ“ä½œæ¨æ–­
        entities = [entity["name"].lower() for entity in semantics["core_entities"]]
        operations = [op["name"].lower() for op in semantics["business_operations"]]
        
        # ä¸šåŠ¡é¢†åŸŸå…³é”®è¯æ˜ å°„
        domain_keywords = {
            "user": ["user", "customer", "account", "profile"],
            "order": ["order", "purchase", "cart", "payment"],
            "product": ["product", "item", "catalog", "inventory"],
            "payment": ["payment", "transaction", "billing", "invoice"],
            "notification": ["notification", "message", "email", "sms"]
        }
        
        domain_scores = {}
        for domain, keywords in domain_keywords.items():
            score = 0
            for keyword in keywords:
                score += sum(1 for entity in entities if keyword in entity)
                score += sum(1 for op in operations if keyword in op)
            domain_scores[domain] = score
        
        # è¿”å›å¾—åˆ†æœ€é«˜çš„é¢†åŸŸ
        return max(domain_scores, key=domain_scores.get) if domain_scores else "unknown"
```

### 3. å¢é‡ä¿®æ”¹å¼•æ“ï¼ˆIncremental Modifierï¼‰
```python
# src/corder_integration/code_modification/incremental_modifier.py
"""
å¢é‡ä¿®æ”¹å¼•æ“ï¼šåœ¨ç°æœ‰ä»£ç åŸºç¡€ä¸Šè¿›è¡Œç²¾ç¡®ä¿®æ”¹
"""

import difflib
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
import ast
import re

class IncrementalModifier:
    """å¢é‡ä¿®æ”¹å¼•æ“"""
    
    def __init__(self):
        self.modification_strategies = {
            "add_method": self._add_method_strategy,
            "modify_method": self._modify_method_strategy,
            "add_field": self._add_field_strategy,
            "modify_field": self._modify_field_strategy,
            "add_annotation": self._add_annotation_strategy,
            "add_import": self._add_import_strategy,
            "add_class": self._add_class_strategy
        }
    
    async def generate_modification_plan(self, 
                                       current_code: Dict[str, Any],
                                       requirements: Dict[str, Any],
                                       existing_semantics: Dict[str, Any]) -> Dict[str, Any]:
        """ç”Ÿæˆä¿®æ”¹è®¡åˆ’"""
        
        modification_plan = {
            "target_service": requirements.get("service_name"),
            "modifications": [],
            "new_files": [],
            "dependency_changes": [],
            "configuration_changes": [],
            "impact_analysis": {}
        }
        
        # åˆ†æéœ€è¦çš„ä¿®æ”¹
        required_changes = await self._analyze_required_changes(requirements, existing_semantics)
        
        # ä¸ºæ¯ä¸ªå˜æ›´ç”Ÿæˆå…·ä½“çš„ä¿®æ”¹æ“ä½œ
        for change in required_changes:
            modification = await self._generate_modification(change, current_code)
            modification_plan["modifications"].append(modification)
        
        # åˆ†æå½±å“èŒƒå›´
        modification_plan["impact_analysis"] = await self._analyze_impact(
            modification_plan["modifications"], 
            current_code
        )
        
        return modification_plan
    
    async def _analyze_required_changes(self, requirements: Dict[str, Any], 
                                      existing_semantics: Dict[str, Any]) -> List[Dict[str, Any]]:
        """åˆ†æéœ€è¦çš„å˜æ›´"""
        changes = []
        
        # åˆ†ææ–°å¢çš„APIéœ€æ±‚
        required_apis = requirements.get("apis", [])
        existing_apis = [api["name"] for api in existing_semantics.get("api_contracts", [])]
        
        for api in required_apis:
            if api["name"] not in existing_apis:
                changes.append({
                    "type": "add_api",
                    "target": "controller",
                    "details": api
                })
        
        # åˆ†ææ–°å¢çš„ä¸šåŠ¡é€»è¾‘éœ€æ±‚
        required_operations = requirements.get("business_operations", [])
        existing_operations = [op["name"] for op in existing_semantics.get("business_operations", [])]
        
        for operation in required_operations:
            if operation["name"] not in existing_operations:
                changes.append({
                    "type": "add_business_operation",
                    "target": "service",
                    "details": operation
                })
        
        # åˆ†ææ–°å¢çš„æ•°æ®æ¨¡å‹éœ€æ±‚
        required_entities = requirements.get("entities", [])
        existing_entities = [entity["name"] for entity in existing_semantics.get("core_entities", [])]
        
        for entity in required_entities:
            if entity["name"] not in existing_entities:
                changes.append({
                    "type": "add_entity",
                    "target": "entity",
                    "details": entity
                })
            else:
                # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿®æ”¹ç°æœ‰å®ä½“
                existing_entity = next((e for e in existing_semantics["core_entities"] if e["name"] == entity["name"]), None)
                if existing_entity:
                    entity_changes = self._compare_entities(existing_entity, entity)
                    if entity_changes:
                        changes.append({
                            "type": "modify_entity",
                            "target": "entity",
                            "details": entity_changes
                        })
        
        return changes
    
    async def _generate_modification(self, change: Dict[str, Any], 
                                   current_code: Dict[str, Any]) -> Dict[str, Any]:
        """ç”Ÿæˆå…·ä½“çš„ä¿®æ”¹æ“ä½œ"""
        
        modification = {
            "change_type": change["type"],
            "target_file": "",
            "operations": [],
            "code_changes": [],
            "rollback_info": {}
        }
        
        if change["type"] == "add_api":
            modification = await self._generate_api_addition(change, current_code)
        elif change["type"] == "add_business_operation":
            modification = await self._generate_business_operation_addition(change, current_code)
        elif change["type"] == "add_entity":
            modification = await self._generate_entity_addition(change, current_code)
        elif change["type"] == "modify_entity":
            modification = await self._generate_entity_modification(change, current_code)
        
        return modification
    
    async def _generate_api_addition(self, change: Dict[str, Any], 
                                   current_code: Dict[str, Any]) -> Dict[str, Any]:
        """ç”ŸæˆAPIæ·»åŠ çš„ä¿®æ”¹"""
        api_details = change["details"]
        
        # æ‰¾åˆ°ç›®æ ‡æ§åˆ¶å™¨æ–‡ä»¶
        controllers = current_code.get("source_files", {}).get("controllers", [])
        target_controller = self._find_target_controller(api_details, controllers)
        
        if not target_controller:
            # éœ€è¦åˆ›å»ºæ–°çš„æ§åˆ¶å™¨
            return await self._generate_new_controller_creation(api_details)
        
        # ç”ŸæˆAPIæ–¹æ³•ä»£ç 
        method_code = self._generate_api_method_code(api_details)
        
        modification = {
            "change_type": "add_api",
            "target_file": target_controller,
            "operations": [
                {
                    "type": "add_method",
                    "position": "end_of_class",
                    "content": method_code
                }
            ],
            "code_changes": [
                {
                    "type": "insertion",
                    "content": method_code,
                    "position": "end_of_class"
                }
            ]
        }
        
        return modification
    
    def _generate_api_method_code(self, api_details: Dict[str, Any]) -> str:
        """ç”ŸæˆAPIæ–¹æ³•ä»£ç """
        method_name = api_details["name"]
        http_method = api_details.get("http_method", "GET")
        path = api_details.get("path", f"/{method_name}")
        parameters = api_details.get("parameters", [])
        return_type = api_details.get("return_type", "String")
        
        # ç”Ÿæˆå‚æ•°åˆ—è¡¨
        param_list = []
        for param in parameters:
            param_annotation = self._get_param_annotation(param)
            param_list.append(f"{param_annotation} {param['type']} {param['name']}")
        
        param_str = ", ".join(param_list)
        
        # ç”Ÿæˆæ–¹æ³•ä½“
        method_body = f"""
    @{http_method}Mapping("{path}")
    public ResponseEntity<{return_type}> {method_name}({param_str}) {{
        // TODO: å®ç°ä¸šåŠ¡é€»è¾‘
        return ResponseEntity.ok().build();
    }}
"""
        
        return method_body
    
    async def apply_modifications(self, modification_plan: Dict[str, Any], 
                                service_path: str) -> Dict[str, Any]:
        """åº”ç”¨ä¿®æ”¹è®¡åˆ’"""
        
        application_result = {
            "success": True,
            "applied_changes": [],
            "failed_changes": [],
            "backup_files": {},
            "rollback_plan": []
        }
        
        for modification in modification_plan["modifications"]:
            try:
                # å¤‡ä»½åŸæ–‡ä»¶
                target_file = os.path.join(service_path, modification["target_file"])
                backup_path = f"{target_file}.backup"
                
                if os.path.exists(target_file):
                    with open(target_file, 'r', encoding='utf-8') as f:
                        original_content = f.read()
                    
                    with open(backup_path, 'w', encoding='utf-8') as f:
                        f.write(original_content)
                    
                    application_result["backup_files"][target_file] = backup_path
                
                # åº”ç”¨ä¿®æ”¹
                modified_content = await self._apply_single_modification(modification, target_file)
                
                # å†™å…¥ä¿®æ”¹åçš„æ–‡ä»¶
                with open(target_file, 'w', encoding='utf-8') as f:
                    f.write(modified_content)
                
                application_result["applied_changes"].append({
                    "file": target_file,
                    "modification": modification,
                    "success": True
                })
                
            except Exception as e:
                application_result["failed_changes"].append({
                    "file": modification["target_file"],
                    "error": str(e),
                    "modification": modification
                })
                application_result["success"] = False
        
        return application_result
    
    async def _apply_single_modification(self, modification: Dict[str, Any], 
                                       target_file: str) -> str:
        """åº”ç”¨å•ä¸ªä¿®æ”¹"""
        
        # è¯»å–åŸæ–‡ä»¶å†…å®¹
        with open(target_file, 'r', encoding='utf-8') as f:
            original_content = f.read()
        
        modified_content = original_content
        
        # åº”ç”¨æ‰€æœ‰æ“ä½œ
        for operation in modification["operations"]:
            if operation["type"] == "add_method":
                modified_content = self._add_method_to_class(modified_content, operation["content"])
            elif operation["type"] == "modify_method":
                modified_content = self._modify_method_in_class(modified_content, operation)
            elif operation["type"] == "add_import":
                modified_content = self._add_import_to_file(modified_content, operation["content"])
            elif operation["type"] == "add_annotation":
                modified_content = self._add_annotation_to_class(modified_content, operation["content"])
        
        return modified_content
    
    def _add_method_to_class(self, content: str, method_code: str) -> str:
        """å‘ç±»ä¸­æ·»åŠ æ–¹æ³•"""
        # æ‰¾åˆ°ç±»çš„ç»“æŸä½ç½®ï¼ˆæœ€åä¸€ä¸ª}ï¼‰
        lines = content.split('\n')
        
        # ä»åå¾€å‰æ‰¾åˆ°ç±»çš„ç»“æŸ}
        for i in range(len(lines) - 1, -1, -1):
            line = lines[i].strip()
            if line == '}' and i > 0:
                # åœ¨}ä¹‹å‰æ’å…¥æ–°æ–¹æ³•
                lines.insert(i, method_code)
                break
        
        return '\n'.join(lines)
    
    def generate_diff_report(self, original_content: str, modified_content: str) -> str:
        """ç”Ÿæˆå·®å¼‚æŠ¥å‘Š"""
        diff = difflib.unified_diff(
            original_content.splitlines(keepends=True),
            modified_content.splitlines(keepends=True),
            fromfile='original',
            tofile='modified'
        )
        
        return ''.join(diff)
```

### 4. ä»£ç ä¸€è‡´æ€§æ£€æŸ¥å™¨ï¼ˆConsistency Checkerï¼‰
```python
# src/corder_integration/code_modification/consistency_checker.py
"""
ä»£ç ä¸€è‡´æ€§æ£€æŸ¥å™¨ï¼šç¡®ä¿ä¿®æ”¹åçš„ä»£ç ä¿æŒä¸€è‡´æ€§
"""

from typing import Dict, List, Any, Optional
import re

class ConsistencyChecker:
    """ä»£ç ä¸€è‡´æ€§æ£€æŸ¥å™¨"""
    
    def __init__(self):
        self.consistency_rules = {
            "naming_convention": self._check_naming_convention,
            "code_style": self._check_code_style,
            "architecture_pattern": self._check_architecture_pattern,
            "dependency_consistency": self._check_dependency_consistency,
            "api_consistency": self._check_api_consistency
        }
    
    async def check_consistency(self, 
                              original_code: Dict[str, Any],
                              modified_code: Dict[str, Any]) -> Dict[str, Any]:
        """æ£€æŸ¥ä»£ç ä¸€è‡´æ€§"""
        
        consistency_report = {
            "overall_score": 0.0,
            "violations": [],
            "recommendations": [],
            "auto_fixes": []
        }
        
        total_checks = 0
        passed_checks = 0
        
        # æ‰§è¡Œæ‰€æœ‰ä¸€è‡´æ€§æ£€æŸ¥
        for rule_name, check_func in self.consistency_rules.items():
            try:
                result = await check_func(original_code, modified_code)
                total_checks += 1
                
                if result["passed"]:
                    passed_checks += 1
                else:
                    consistency_report["violations"].append({
                        "rule": rule_name,
                        "description": result["description"],
                        "severity": result["severity"],
                        "locations": result["locations"]
                    })
                    
                    if result.get("recommendation"):
                        consistency_report["recommendations"].append({
                            "rule": rule_name,
                            "recommendation": result["recommendation"]
                        })
                    
                    if result.get("auto_fix"):
                        consistency_report["auto_fixes"].append({
                            "rule": rule_name,
                            "fix": result["auto_fix"]
                        })
                
            except Exception as e:
                consistency_report["violations"].append({
                    "rule": rule_name,
                    "description": f"æ£€æŸ¥å¤±è´¥: {str(e)}",
                    "severity": "error"
                })
        
        # è®¡ç®—æ€»ä½“å¾—åˆ†
        consistency_report["overall_score"] = (passed_checks / total_checks) * 100 if total_checks > 0 else 0
        
        return consistency_report
    
    async def _check_naming_convention(self, original_code: Dict[str, Any], 
                                     modified_code: Dict[str, Any]) -> Dict[str, Any]:
        """æ£€æŸ¥å‘½åçº¦å®š"""
        # æå–åŸæœ‰ä»£ç çš„å‘½åæ¨¡å¼
        original_patterns = self._extract_naming_patterns(original_code)
        
        # æ£€æŸ¥æ–°ä»£ç æ˜¯å¦éµå¾ªç›¸åŒæ¨¡å¼
        violations = []
        
        # æ£€æŸ¥ç±»å‘½å
        for class_name in modified_code.get("classes", []):
            if not self._matches_naming_pattern(class_name, original_patterns["classes"]):
                violations.append({
                    "type": "class_naming",
                    "name": class_name,
                    "expected_pattern": original_patterns["classes"]
                })
        
        return {
            "passed": len(violations) == 0,
            "description": "å‘½åçº¦å®šæ£€æŸ¥",
            "severity": "warning",
            "locations": violations,
            "recommendation": "è¯·éµå¾ªç°æœ‰çš„å‘½åçº¦å®šæ¨¡å¼"
        }
    
    def _extract_naming_patterns(self, code: Dict[str, Any]) -> Dict[str, str]:
        """æå–å‘½åæ¨¡å¼"""
        patterns = {
            "classes": "PascalCase",
            "methods": "camelCase",
            "fields": "camelCase",
            "constants": "UPPER_SNAKE_CASE"
        }
        
        # å¯ä»¥æ ¹æ®å®é™…ä»£ç åˆ†æå…·ä½“çš„å‘½åæ¨¡å¼
        return patterns
```

### 5. é›†æˆåˆ°ç°æœ‰å·¥ä½œæµ
```python
# src/corder_integration/langgraph/nodes/intelligent_coding_node.py
"""
æ™ºèƒ½ç¼–ç èŠ‚ç‚¹ - é›†æˆå†å²ä»£ç åˆ†æå’Œä¿®æ”¹åŠŸèƒ½
"""

from ..code_analysis.code_discovery import CodeDiscovery
from ..code_analysis.semantic_analyzer import SemanticAnalyzer
from ..code_modification.incremental_modifier import IncrementalModifier
from ..code_modification.consistency_checker import ConsistencyChecker

async def intelligent_coding_node(state: CodingAgentState) -> CodingAgentState:
    """æ™ºèƒ½ç¼–ç èŠ‚ç‚¹ - æ”¯æŒå†å²ä»£ç åˆ†æå’Œä¿®æ”¹"""
    
    # ğŸ” 1. å‘ç°å’Œåˆ†æç°æœ‰ä»£ç 
    discovery = CodeDiscovery(state["project_paths"]["main"])
    existing_structure = await discovery.discover_project_structure(state["target_branch"])
    
    # ğŸ“Š 2. è¯­ä¹‰åˆ†æ
    semantic_analyzer = SemanticAnalyzer()
    existing_semantics = {}
    
    for service_name, service_info in existing_structure["services"].items():
        service_semantics = await semantic_analyzer.analyze_service_semantics(
            service_info["path"], 
            service_info["source_files"]
        )
        existing_semantics[service_name] = service_semantics
    
    # ğŸ”„ 3. ç”Ÿæˆä¿®æ”¹è®¡åˆ’
    modifier = IncrementalModifier()
    
    for service_name in state["identified_services"]:
        if service_name in existing_structure["services"]:
            # ç°æœ‰æœåŠ¡ï¼šç”Ÿæˆå¢é‡ä¿®æ”¹
            requirements = state["service_requirements"][service_name]
            current_code = existing_structure["services"][service_name]
            existing_semantic = existing_semantics[service_name]
            
            modification_plan = await modifier.generate_modification_plan(
                current_code, requirements, existing_semantic
            )
            
            # åº”ç”¨ä¿®æ”¹
            application_result = await modifier.apply_modifications(
                modification_plan, current_code["path"]
            )
            
            # ä¸€è‡´æ€§æ£€æŸ¥
            consistency_checker = ConsistencyChecker()
            consistency_report = await consistency_checker.check_consistency(
                current_code, application_result
            )
            
            # æ›´æ–°çŠ¶æ€
            state["generated_services"][service_name] = {
                "type": "incremental_modification",
                "modification_plan": modification_plan,
                "application_result": application_result,
                "consistency_report": consistency_report
            }
        else:
            # æ–°æœåŠ¡ï¼šä»å¤´ç”Ÿæˆ
            generated_code = await generate_new_service(service_name, state)
            state["generated_services"][service_name] = {
                "type": "new_service",
                "generated_code": generated_code
            }
    
    # ğŸ’¾ 4. ä¿å­˜å†å²ä»£ç åˆ†æç»“æœåˆ°è®°å¿†ç³»ç»Ÿ
    await state["memory_manager"].store_context(
        "code_analysis_result",
        {
            "project_structure": existing_structure,
            "semantics": existing_semantics,
            "analysis_timestamp": datetime.now().isoformat()
        },
        persistence_level="short_term"
    )
    
    state["current_phase"] = "code_review"
    return state
```

## ğŸ¯ ä½¿ç”¨ç¤ºä¾‹

```python
# ä½¿ç”¨å†å²ä»£ç åˆ†æå’Œä¿®æ”¹åŠŸèƒ½
async def example_usage():
    """ç¤ºä¾‹ï¼šåœ¨ç°æœ‰ç”¨æˆ·æœåŠ¡åŸºç¡€ä¸Šæ·»åŠ æ–°åŠŸèƒ½"""
    
    # 1. å‘ç°ç°æœ‰ä»£ç 
    discovery = CodeDiscovery("/path/to/user-service")
    existing_structure = await discovery.discover_project_structure("main")
    
    # 2. åˆ†æç°æœ‰è¯­ä¹‰
    analyzer = SemanticAnalyzer()
    existing_semantics = await analyzer.analyze_service_semantics(
        existing_structure["services"]["user-service"]["path"],
        existing_structure["services"]["user-service"]["source_files"]
    )
    
    # 3. å®šä¹‰æ–°éœ€æ±‚
    requirements = {
        "service_name": "user-service",
        "apis": [
            {
                "name": "updateUserProfile",
                "http_method": "PUT",
                "path": "/users/{id}/profile",
                "parameters": [
                    {"name": "id", "type": "Long", "annotation": "@PathVariable"},
                    {"name": "profile", "type": "UserProfile", "annotation": "@RequestBody"}
                ]
            }
        ],
        "business_operations": [
            {
                "name": "updateProfile",
                "parameters": [
                    {"name": "userId", "type": "Long"},
                    {"name": "profile", "type": "UserProfile"}
                ],
                "return_type": "UserProfile"
            }
        ]
    }
    
    # 4. ç”Ÿæˆä¿®æ”¹è®¡åˆ’
    modifier = IncrementalModifier()
    modification_plan = await modifier.generate_modification_plan(
        existing_structure["services"]["user-service"],
        requirements,
        existing_semantics
    )
    
    # 5. åº”ç”¨ä¿®æ”¹
    result = await modifier.apply_modifications(
        modification_plan,
        existing_structure["services"]["user-service"]["path"]
    )
    
    print(f"ä¿®æ”¹ç»“æœ: {result}")
```

## ğŸ“Š æ ¸å¿ƒç‰¹æ€§æ€»ç»“

### ğŸ” å†å²ä»£ç åˆ†æèƒ½åŠ›
1. **é¡¹ç›®ç»“æ„å‘ç°** - è‡ªåŠ¨è¯†åˆ«å¾®æœåŠ¡ã€å…±äº«æ¨¡å—ã€é…ç½®æ–‡ä»¶
2. **ä»£ç è¯­ä¹‰åˆ†æ** - æ·±åº¦ç†è§£ä¸šåŠ¡é€»è¾‘ã€æ•°æ®æ¨¡å‹ã€APIæ¥å£
3. **æ¶æ„æ¨¡å¼è¯†åˆ«** - è¯†åˆ«ç°æœ‰çš„è®¾è®¡æ¨¡å¼å’Œæ¶æ„é£æ ¼
4. **ä¾èµ–å…³ç³»åˆ†æ** - åˆ†ææœåŠ¡é—´ä¾èµ–å’Œæ•°æ®æµ

### ğŸ”„ å¢é‡ä¿®æ”¹èƒ½åŠ›
1. **ç²¾ç¡®ä¿®æ”¹** - åœ¨ç°æœ‰ä»£ç åŸºç¡€ä¸Šè¿›è¡Œæœ€å°åŒ–ä¿®æ”¹
2. **æ™ºèƒ½æ’å…¥** - è‡ªåŠ¨è¯†åˆ«æœ€ä½³æ’å…¥ä½ç½®
3. **ä¸€è‡´æ€§ä¿æŒ** - ç¡®ä¿ä¿®æ”¹åçš„ä»£ç é£æ ¼å’Œæ¶æ„ä¸€è‡´
4. **å½±å“åˆ†æ** - åˆ†æä¿®æ”¹å¯¹å…¶ä»–æ¨¡å—çš„å½±å“

### ğŸ“ ä»£ç è´¨é‡ä¿è¯
1. **å·®å¼‚å¯¹æ¯”** - ç”Ÿæˆè¯¦ç»†çš„ä»£ç å˜æ›´æŠ¥å‘Š
2. **ä¸€è‡´æ€§æ£€æŸ¥** - å¤šç»´åº¦æ£€æŸ¥ä»£ç ä¸€è‡´æ€§
3. **è‡ªåŠ¨ä¿®å¤** - æä¾›è‡ªåŠ¨ä¿®å¤å»ºè®®
4. **å›æ»šæ”¯æŒ** - æ”¯æŒä¿®æ”¹å›æ»šå’Œç‰ˆæœ¬ç®¡ç†

è¿™ä¸ªå†å²ä»£ç è¯»å–å’Œä¿®æ”¹æœºåˆ¶å°†è®©ç¼–ç æ™ºèƒ½ä½“å…·å¤‡çœŸæ­£çš„"ä»£ç ç†è§£"å’Œ"å¢é‡å¼€å‘"èƒ½åŠ›ï¼ 