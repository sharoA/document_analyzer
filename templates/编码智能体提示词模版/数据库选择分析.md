# ğŸ—„ï¸ LangGraph Checkpointer æ•°æ®åº“é€‰æ‹©åˆ†æ

## ğŸ“Š PostgreSQL vs MySQL å¯¹æ¯”åˆ†æ

### 1. LangGraph Checkpointer çš„æŠ€æœ¯éœ€æ±‚

```python
# LangGraph Checkpointer éœ€è¦çš„æ ¸å¿ƒåŠŸèƒ½ï¼š
1. å¤æ‚JSONæ•°æ®å­˜å‚¨å’ŒæŸ¥è¯¢
2. äº‹åŠ¡ä¸€è‡´æ€§ä¿è¯
3. å¹¶å‘çŠ¶æ€ç®¡ç†
4. çŠ¶æ€ç‰ˆæœ¬æ§åˆ¶
5. å¿«é€Ÿåºåˆ—åŒ–/ååºåˆ—åŒ–
6. çŠ¶æ€å¿«ç…§å’Œå›æ»š
```

### 2. PostgreSQL çš„ä¼˜åŠ¿

| ç‰¹æ€§ | PostgreSQL | MySQL | é€‰æ‹©ç†ç”± |
|------|------------|--------|----------|
| **JSONæ”¯æŒ** | åŸç”ŸJSON/JSONBç±»å‹ | JSONç±»å‹ï¼ˆ5.7+ï¼‰ | PostgreSQLçš„JSONBæ€§èƒ½æ›´å¥½ |
| **å¤æ‚æŸ¥è¯¢** | å¼ºå¤§çš„JSONæŸ¥è¯¢è¯­æ³• | ç›¸å¯¹ç®€å•çš„JSONå‡½æ•° | çŠ¶æ€æŸ¥è¯¢éœ€è¦å¤æ‚JSONæ“ä½œ |
| **äº‹åŠ¡éš”ç¦»** | æ”¯æŒæ‰€æœ‰éš”ç¦»çº§åˆ« | æ”¯æŒå¤§éƒ¨åˆ†éš”ç¦»çº§åˆ« | éœ€è¦ä¸¥æ ¼çš„äº‹åŠ¡ä¸€è‡´æ€§ |
| **å¹¶å‘æ§åˆ¶** | MVCCæœºåˆ¶æ›´æˆç†Ÿ | è¡Œçº§é”å®š | å¤šæ™ºèƒ½ä½“å¹¶å‘æ‰§è¡Œ |
| **æ‰©å±•æ€§** | ä¸°å¯Œçš„æ‰©å±•æ’ä»¶ | æ’ä»¶ç›¸å¯¹è¾ƒå°‘ | å¯èƒ½éœ€è¦è‡ªå®šä¹‰æ‰©å±• |

### 3. å®é™…æŠ€æœ¯å¯¹æ¯”

```python
# PostgreSQL å­˜å‚¨LangGraphçŠ¶æ€çš„ä¼˜åŠ¿

# 1. JSONBå­—æ®µç›´æ¥å­˜å‚¨å¤æ‚çŠ¶æ€
CREATE TABLE langgraph_checkpoints (
    thread_id VARCHAR(255) PRIMARY KEY,
    checkpoint_id VARCHAR(255),
    parent_checkpoint_id VARCHAR(255),
    state JSONB,  -- ğŸ”¥ æ ¸å¿ƒä¼˜åŠ¿ï¼šåŸç”ŸJSONB
    config JSONB,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

# 2. å¼ºå¤§çš„JSONæŸ¥è¯¢èƒ½åŠ›
SELECT * FROM langgraph_checkpoints 
WHERE state->'completed_services' ? 'user-service'  -- ğŸ”¥ ç›´æ¥æŸ¥è¯¢JSONå†…å®¹
  AND state->'current_phase' = '"coding"'
  AND (state->'retry_count')::int < 3;

# 3. JSONè·¯å¾„æ›´æ–°
UPDATE langgraph_checkpoints 
SET state = jsonb_set(state, '{current_phase}', '"testing"')
WHERE thread_id = 'session_123';
```

### 4. MySQL çš„æŒ‘æˆ˜

```python
# MySQL å­˜å‚¨LangGraphçŠ¶æ€çš„é™åˆ¶

# 1. JSONæŸ¥è¯¢è¯­æ³•ç›¸å¯¹å¤æ‚
SELECT * FROM langgraph_checkpoints 
WHERE JSON_CONTAINS(state, '["user-service"]', '$.completed_services')
  AND JSON_EXTRACT(state, '$.current_phase') = 'coding'
  AND JSON_EXTRACT(state, '$.retry_count') < 3;

# 2. JSONæ›´æ–°è¾ƒä¸ºç¹ç
UPDATE langgraph_checkpoints 
SET state = JSON_SET(state, '$.current_phase', 'testing')
WHERE thread_id = 'session_123';
```

## ğŸ”„ **è§£å†³æ–¹æ¡ˆï¼šæ”¯æŒMySQLçš„å…¼å®¹å®ç°**

è™½ç„¶PostgreSQLæ›´é€‚åˆï¼Œä½†å¦‚æœé¡¹ç›®å¿…é¡»ä½¿ç”¨MySQLï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºå…¼å®¹å®ç°ï¼š

```python
# src/corder_integration/langgraph/checkpointer/mysql_checkpointer.py
"""
MySQLå…¼å®¹çš„LangGraph Checkpointerå®ç°
"""

import json
import mysql.connector
from typing import Dict, Any, Optional, List
from langgraph.checkpoint.base import Checkpointer
from langgraph.checkpoint.mysql import MySQLCheckpointer  # å‡è®¾æœ‰æ­¤å®ç°

class CustomMySQLCheckpointer(Checkpointer):
    """è‡ªå®šä¹‰MySQLæ£€æŸ¥ç‚¹å®ç°"""
    
    def __init__(self, connection_string: str):
        self.connection_string = connection_string
        self.connection = mysql.connector.connect(
            **self._parse_connection_string(connection_string)
        )
        self._init_tables()
    
    def _init_tables(self):
        """åˆå§‹åŒ–MySQLè¡¨ç»“æ„"""
        cursor = self.connection.cursor()
        
        # åˆ›å»ºæ£€æŸ¥ç‚¹è¡¨
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS langgraph_checkpoints (
                thread_id VARCHAR(255) NOT NULL,
                checkpoint_id VARCHAR(255) NOT NULL,
                parent_checkpoint_id VARCHAR(255),
                state JSON NOT NULL,
                config JSON,
                metadata JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (thread_id, checkpoint_id),
                INDEX idx_thread_id (thread_id),
                INDEX idx_checkpoint_id (checkpoint_id)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        """)
        
        # åˆ›å»ºçŠ¶æ€å¿«ç…§è¡¨ï¼ˆä¼˜åŒ–æŸ¥è¯¢ï¼‰
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS langgraph_state_snapshots (
                thread_id VARCHAR(255) NOT NULL,
                checkpoint_id VARCHAR(255) NOT NULL,
                current_phase VARCHAR(100),
                completed_services JSON,
                failed_services JSON,
                retry_count INT DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (thread_id, checkpoint_id),
                INDEX idx_phase (current_phase),
                INDEX idx_retry (retry_count)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        """)
        
        self.connection.commit()
    
    async def aput(self, thread_id: str, checkpoint_id: str, state: Dict[str, Any], 
                   config: Dict[str, Any] = None, metadata: Dict[str, Any] = None):
        """ä¿å­˜æ£€æŸ¥ç‚¹çŠ¶æ€"""
        cursor = self.connection.cursor()
        
        try:
            # 1. ä¿å­˜å®Œæ•´çŠ¶æ€
            cursor.execute("""
                INSERT INTO langgraph_checkpoints 
                (thread_id, checkpoint_id, state, config, metadata)
                VALUES (%s, %s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE
                state = VALUES(state),
                config = VALUES(config),
                metadata = VALUES(metadata)
            """, (
                thread_id,
                checkpoint_id,
                json.dumps(state),
                json.dumps(config or {}),
                json.dumps(metadata or {})
            ))
            
            # 2. ä¿å­˜çŠ¶æ€å¿«ç…§ï¼ˆä¼˜åŒ–æŸ¥è¯¢ï¼‰
            cursor.execute("""
                INSERT INTO langgraph_state_snapshots 
                (thread_id, checkpoint_id, current_phase, completed_services, 
                 failed_services, retry_count)
                VALUES (%s, %s, %s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE
                current_phase = VALUES(current_phase),
                completed_services = VALUES(completed_services),
                failed_services = VALUES(failed_services),
                retry_count = VALUES(retry_count)
            """, (
                thread_id,
                checkpoint_id,
                state.get('current_phase', ''),
                json.dumps(state.get('completed_services', [])),
                json.dumps(state.get('failed_services', [])),
                state.get('retry_count', 0)
            ))
            
            self.connection.commit()
            
        except Exception as e:
            self.connection.rollback()
            raise e
    
    async def aget(self, thread_id: str, checkpoint_id: str = None) -> Optional[Dict[str, Any]]:
        """è·å–æ£€æŸ¥ç‚¹çŠ¶æ€"""
        cursor = self.connection.cursor()
        
        if checkpoint_id:
            cursor.execute("""
                SELECT state, config, metadata 
                FROM langgraph_checkpoints 
                WHERE thread_id = %s AND checkpoint_id = %s
            """, (thread_id, checkpoint_id))
        else:
            cursor.execute("""
                SELECT state, config, metadata 
                FROM langgraph_checkpoints 
                WHERE thread_id = %s 
                ORDER BY created_at DESC 
                LIMIT 1
            """, (thread_id,))
        
        result = cursor.fetchone()
        if result:
            return {
                'state': json.loads(result[0]),
                'config': json.loads(result[1] or '{}'),
                'metadata': json.loads(result[2] or '{}')
            }
        return None
    
    async def alist(self, thread_id: str, limit: int = 10) -> List[Dict[str, Any]]:
        """åˆ—å‡ºæ£€æŸ¥ç‚¹å†å²"""
        cursor = self.connection.cursor()
        
        cursor.execute("""
            SELECT checkpoint_id, state, config, metadata, created_at
            FROM langgraph_checkpoints 
            WHERE thread_id = %s 
            ORDER BY created_at DESC 
            LIMIT %s
        """, (thread_id, limit))
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'checkpoint_id': row[0],
                'state': json.loads(row[1]),
                'config': json.loads(row[2] or '{}'),
                'metadata': json.loads(row[3] or '{}'),
                'created_at': row[4]
            })
        
        return results
    
    async def query_by_phase(self, current_phase: str, limit: int = 10) -> List[Dict[str, Any]]:
        """æŒ‰é˜¶æ®µæŸ¥è¯¢ï¼ˆåˆ©ç”¨ä¼˜åŒ–è¡¨ï¼‰"""
        cursor = self.connection.cursor()
        
        cursor.execute("""
            SELECT s.thread_id, s.checkpoint_id, c.state
            FROM langgraph_state_snapshots s
            JOIN langgraph_checkpoints c ON s.thread_id = c.thread_id 
                AND s.checkpoint_id = c.checkpoint_id
            WHERE s.current_phase = %s
            ORDER BY s.created_at DESC
            LIMIT %s
        """, (current_phase, limit))
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'thread_id': row[0],
                'checkpoint_id': row[1],
                'state': json.loads(row[2])
            })
        
        return results

# é…ç½®å·¥å‚
class CheckpointerFactory:
    """æ£€æŸ¥ç‚¹å™¨å·¥å‚"""
    
    @staticmethod
    def create_checkpointer(db_type: str, connection_string: str) -> Checkpointer:
        """åˆ›å»ºæ£€æŸ¥ç‚¹å™¨"""
        if db_type.lower() == 'postgresql':
            from langgraph.checkpoint.postgres import PostgresCheckpointer
            return PostgresCheckpointer.from_conn_string(connection_string)
        elif db_type.lower() == 'mysql':
            return CustomMySQLCheckpointer(connection_string)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æ•°æ®åº“ç±»å‹: {db_type}")
```

## ğŸ’¡ **æ¨èç­–ç•¥**

```python
# src/corder_integration/config.py
"""
æ•°æ®åº“é…ç½®ç­–ç•¥
"""

DATABASE_CONFIG = {
    # ä¼˜å…ˆä½¿ç”¨PostgreSQLï¼ˆæ¨èï¼‰
    "preferred": {
        "type": "postgresql",
        "connection_string": "postgresql://user:pass@localhost/coding_agent_db",
        "features": ["jsonb", "complex_queries", "extensions"]
    },
    
    # å¤‡é€‰MySQLï¼ˆå…¼å®¹ï¼‰
    "fallback": {
        "type": "mysql", 
        "connection_string": "mysql://user:pass@localhost/coding_agent_db",
        "features": ["json", "basic_queries", "standard_sql"]
    },
    
    # è‡ªåŠ¨é€‰æ‹©ç­–ç•¥
    "auto_detect": True,
    "migration_support": True  # æ”¯æŒä»MySQLè¿ç§»åˆ°PostgreSQL
}

# ä½¿ç”¨ç¤ºä¾‹
def get_checkpointer():
    """è·å–æ£€æŸ¥ç‚¹å™¨"""
    config = DATABASE_CONFIG
    
    if config["auto_detect"]:
        # è‡ªåŠ¨æ£€æµ‹å¯ç”¨çš„æ•°æ®åº“
        try:
            return CheckpointerFactory.create_checkpointer("postgresql", config["preferred"]["connection_string"])
        except:
            return CheckpointerFactory.create_checkpointer("mysql", config["fallback"]["connection_string"])
    else:
        # æ‰‹åŠ¨æŒ‡å®š
        return CheckpointerFactory.create_checkpointer("mysql", config["fallback"]["connection_string"])
```

## ğŸ“ **æ€»ç»“**

1. **PostgreSQLä¼˜åŠ¿**ï¼šåŸç”ŸJSONBæ”¯æŒã€å¤æ‚æŸ¥è¯¢ã€æ›´å¥½çš„å¹¶å‘æ§åˆ¶
2. **MySQLå¯è¡Œæ€§**ï¼šé€šè¿‡ä¼˜åŒ–è¡¨ç»“æ„å’ŒæŸ¥è¯¢ç­–ç•¥ï¼Œå®Œå…¨å¯ä»¥æ”¯æŒ
3. **æ¨èç­–ç•¥**ï¼šä¼˜å…ˆPostgreSQLï¼Œæä¾›MySQLå…¼å®¹å®ç°
4. **è¿ç§»å‹å¥½**ï¼šæ”¯æŒä»MySQLå¹³æ»‘è¿ç§»åˆ°PostgreSQL

**ç»“è®º**ï¼šè™½ç„¶PostgreSQLæ›´é€‚åˆLangGraphçš„å¤æ‚çŠ¶æ€ç®¡ç†ï¼Œä½†MySQLå®Œå…¨å¯ä»¥é€šè¿‡è‡ªå®šä¹‰å®ç°æ¥æ”¯æŒã€‚æˆ‘ä»¬å¯ä»¥æä¾›ä¸¤ç§æ–¹æ¡ˆä¾›æ‚¨é€‰æ‹©ï¼ 