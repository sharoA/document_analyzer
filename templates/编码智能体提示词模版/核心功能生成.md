# 🎯 编码智能体核心功能实现指南

## 🔄 核心流程梳理

基于架构图，编码智能体的核心流程为：
**输入：需求文档 + 设计文档** → 编码智能体（**任务拆分调度** → **LangGraph工作流控制** → **智能体执行** → **Git提交推送**）

当前实现流程图：
graph TD
    A["📄 输入文档"] --> B["🧠 TaskSplittingNode"]
    
    B --> B1["🤖 LLM: 需求分析<br/>prompt: requirement_analysis"]
    B1 --> B2["🤖 LLM: 设计分析<br/>prompt: design_analysis"]
    B2 --> B3["🤖 LLM: 微服务识别<br/>prompt: service_boundary"]
    B3 --> B4["🤖 LLM: 依赖分析<br/>prompt: dependency_analysis"]
    B4 --> B5["🤖 LLM: 执行计划<br/>prompt: task_scheduling"]
    
    B5 --> C{"🔍 DependencyChecker"}
    C -->|"通过"| D["🔧 GitManagementNode"]
    C -->|"失败"| B
    
    D --> D1["🤖 LLM: Git信息提取<br/>prompt: git_extraction"]
    D1 --> E{"🏗️ ServiceChecker"}
    E -->|"通过"| F["💻 IntelligentCodingNode"]
    E -->|"失败"| D
    
    F --> F1["🤖 LLM: 服务需求分析<br/>prompt: service_analysis"]
    F1 --> F2["🤖 LLM: 代码生成<br/>prompt: code_generation"]
    F2 --> F3["🤖 LLM: API设计<br/>prompt: api_design"]
    F3 --> F4["🤖 LLM: 服务互联<br/>prompt: service_interconnect"]
    
    F4 --> G["🔍 CodeReviewNode"]
    G --> G1["🤖 LLM: 代码审查<br/>prompt: code_review"]
    G1 --> G2["🤖 LLM: 安全检查<br/>prompt: security_check"]
    G2 --> H{"✅ QualityChecker"}
    H -->|"通过"| I["🧪 UnitTestingNode"]
    H -->|"失败"| F
    
    I --> I1["🤖 LLM: 测试生成<br/>prompt: test_generation"]
    I1 --> I2["🤖 LLM: Mock生成<br/>prompt: mock_generation"]
    I2 --> J{"🧪 TestChecker"}
    J -->|"通过"| K["📤 GitCommitNode"]
    J -->|"失败"| F
    
    K --> K1["🤖 LLM: 提交信息生成<br/>prompt: commit_message"]
    K1 --> K2["🤖 LLM: PR描述生成<br/>prompt: pr_description"]
    K2 --> L["✅ 完成"]
    
    style B1 fill:#ffeb3b
    style B2 fill:#ffeb3b
    style B3 fill:#ffeb3b
    style B4 fill:#ffeb3b
    style B5 fill:#ffeb3b
    style D1 fill:#ffeb3b
    style F1 fill:#ffeb3b
    style F2 fill:#ffeb3b
    style F3 fill:#ffeb3b
    style F4 fill:#ffeb3b
    style G1 fill:#ffeb3b
    style G2 fill:#ffeb3b
    style I1 fill:#ffeb3b
    style I2 fill:#ffeb3b
    style K1 fill:#ffeb3b
    style K2 fill:#ffeb3b



### 📋 完整数据流向
```
输入层(需求文档+设计文档通过coder_agent_api.py的/process-document方法调用) 
↓
任务拆分调度层(任务拆分智能体，希望任务拆分智能体能ReAct验证自己拆分任务的颗粒度要拆分到实现每一个任务的程度) 
↓
LangGraph工作流控制层(StateGraph+PostgreSQL检查点) 
↓
执行智能体层(Git管理→编码→测试→git提交)
↑
支撑层(MCP工具+记忆+提示词)
```

---

## 🏗️ 第一阶段：LangGraph工作流核心引擎

### 🔥 **核心起点：workflow_orchestrator.py**

**目录结构：**
```
src/corder_integration/
├── __init__.py
├── langgraph/
│   ├── __init__.py
│   ├── workflow_orchestrator.py    # 🔥 从这里开始！
│   ├── state_manager.py           # 状态管理器
│   ├── nodes/                     # 工作流节点
│   │   ├── __init__.py
│   │   ├── task_splitting_node.py     # 任务拆分节点
│   │   ├── git_management_node.py     # Git管理节点
│   │   ├── intelligent_coding_node.py # 智能编码节点
│   │   ├── code_review_node.py        # 代码审查节点
│   │   ├── unit_testing_node.py       # 单元测试节点
│   │   └── git_commit_node.py         # Git提交节点
│   └── conditions/                # 条件控制
│       ├── __init__.py
│       ├── dependency_checker.py      # 任务依赖检查
│       ├── service_checker.py         # 服务兼容性检查
│       ├── test_checker.py            # 测试结果检查
│       └── quality_checker.py         # 质量门禁检查
```

### 🎯 **workflow_orchestrator.py 实现提示词**

```python
"""
LangGraph工作流编排器 - 系统核心大脑
功能：基于PostgreSQL检查点的状态管理，编排微服务代码生成全流程
技术栈：SpringBoot + Nacos + Java8 + MyBatis
"""

# 🔧 核心导入
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.postgres import PostgresCheckpointer
from typing import TypedDict, List, Dict, Any, Optional, Annotated
from typing_extensions import TypedDict
import asyncio
import logging

# 📊 状态定义（LangGraph状态管理核心）
class CodingAgentState(TypedDict):
    """编码智能体完整状态定义"""
    
    # 🔄 输入状态
    requirements_doc: str                    # 需求文档内容
    design_doc: str                         # 设计文档内容
    project_name: str                       # 项目名称
    
    # 🧠 任务拆分结果
    identified_services: List[str]          # 识别的微服务列表 ["user-service", "order-service"]
    service_dependencies: Dict[str, List[str]]  # 服务依赖关系图
    task_execution_plan: Dict[str, Any]     # 任务执行计划
    parallel_tasks: List[Dict[str, Any]]    # 可并行执行的任务
    
    # 🔧 Git管理状态
    git_repo_url: Optional[str]             # 从设计文档解析的Git地址
    target_branch: str                      # 目标分支名称
    project_paths: Dict[str, str]           # 各微服务的项目路径
    repo_initialized: bool                  # 仓库初始化状态
    
    # 💻 代码生成状态
    generated_services: Dict[str, Dict[str, Any]]  # 已生成的服务代码
    generated_apis: Dict[str, List[str]]    # 生成的API接口
    generated_sql: Dict[str, List[str]]     # 生成的SQL语句
    service_interconnections: Dict[str, Dict[str, Any]]  # 服务间调用关系
    
    # 🧪 测试状态
    unit_test_results: Dict[str, Dict[str, Any]]    # 单元测试结果
    test_coverage: Dict[str, float]         # 测试覆盖率
    interface_compatibility: Dict[str, bool] # 接口兼容性检查结果
    
    # 🔍 质量检查状态
    code_review_results: Dict[str, Dict[str, Any]]  # 代码审查结果
    static_analysis_results: Dict[str, Any]         # 静态分析结果
    security_scan_results: Dict[str, Any]           # 安全扫描结果
    
    # 📤 Git提交状态
    commit_hashes: Dict[str, str]           # 各服务的提交哈希
    push_results: Dict[str, bool]           # 推送结果
    pr_urls: Dict[str, str]                 # PR地址
    
    # 🔄 执行控制状态
    current_phase: str                      # 当前执行阶段
    completed_services: List[str]           # 已完成的服务
    failed_services: List[str]              # 失败的服务
    retry_count: int                        # 重试次数
    execution_errors: List[str]             # 执行错误列表

# 🤖 LangGraph工作流编排器类
class LangGraphWorkflowOrchestrator:
    """基于LangGraph的微服务编码工作流编排器"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.graph = self._build_workflow_graph()
        self.checkpointer = self._setup_postgres_checkpointer()
        self.compiled_graph = self.graph.compile(checkpointer=self.checkpointer)
    
    def _setup_mysql_checkpointer(self) -> MysqlCheckpointer:
        """设置Mysql检查点管理器"""
      
    
    def _build_workflow_graph(self) -> StateGraph:
        """构建LangGraph工作流图 - 微服务编码专用流程"""
        workflow = StateGraph(CodingAgentState)
        
        # 🧠 添加工作流节点（按执行顺序）
        workflow.add_node("task_splitting", self.task_splitting_node)
        workflow.add_node("git_management", self.git_management_node)
        workflow.add_node("intelligent_coding", self.intelligent_coding_node)
        workflow.add_node("code_review", self.code_review_node)
        workflow.add_node("unit_testing", self.unit_testing_node)
        workflow.add_node("git_commit", self.git_commit_node)
        
        # 🚀 设置工作流入口
        workflow.set_entry_point("task_splitting")
        
        # 🔄 定义节点流转逻辑
        workflow.add_edge("task_splitting", "git_management")
        
        # Git管理 → 智能编码（支持条件分支）
        workflow.add_conditional_edges(
            "git_management",
            self.check_git_setup_success,
            {
                "success": "intelligent_coding",
                "retry": "git_management",
                "fail": END
            }
        )
        
        # 智能编码 → 代码审查（支持重试逻辑）
        workflow.add_conditional_edges(
            "intelligent_coding", 
            self.check_coding_completion,
            {
                "all_completed": "code_review",
                "partial_completed": "intelligent_coding",  # 继续编码未完成的服务
                "dependencies_waiting": "intelligent_coding",  # 等待依赖服务完成
                "critical_error": END
            }
        )
        
        # 代码审查 → 单元测试
        workflow.add_conditional_edges(
            "code_review",
            self.check_review_quality,
            {
                "quality_passed": "unit_testing", 
                "quality_failed": "intelligent_coding",  # 返回重新编码
                "security_risk": END
            }
        )
        
        # 单元测试 → Git提交
        workflow.add_conditional_edges(
            "unit_testing",
            self.check_test_results,
            {
                "tests_passed": "git_commit",
                "tests_failed": "intelligent_coding",  # 返回修复代码
                "coverage_insufficient": "unit_testing"  # 补充测试
            }
        )
        
        # Git提交 → 结束
        workflow.add_edge("git_commit", END)
        
        return workflow
    
    # 🔄 条件检查函数
    def check_git_setup_success(self, state: CodingAgentState) -> str:
        """检查Git环境设置是否成功"""
        if state["repo_initialized"]:
            return "success"
        elif state["retry_count"] < 3:
            return "retry"
        else:
            return "fail"
    
    def check_coding_completion(self, state: CodingAgentState) -> str:
        """检查编码完成状态"""
        total_services = len(state["identified_services"])
        completed_services = len(state["completed_services"])
        
        if completed_services == total_services:
            return "all_completed"
        elif len(state["failed_services"]) > 0:
            return "critical_error"
        else:
            # 检查是否有依赖等待
            for service in state["identified_services"]:
                if service not in state["completed_services"]:
                    dependencies = state["service_dependencies"].get(service, [])
                    if any(dep not in state["completed_services"] for dep in dependencies):
                        return "dependencies_waiting"
            return "partial_completed"
    
    def check_review_quality(self, state: CodingAgentState) -> str:
        """检查代码审查质量"""
        # 实现代码质量检查逻辑
        return "quality_passed"  # 简化实现
    
    def check_test_results(self, state: CodingAgentState) -> str:
        """检查测试结果"""
        # 实现测试结果检查逻辑
        return "tests_passed"  # 简化实现
    
    # 🚀 主执行函数
    async def execute_coding_workflow(
        self, 
        requirements_doc: str, 
        design_doc: str, 
        project_name: str
    ) -> Dict[str, Any]:
        """执行完整的编码工作流"""
        
        # 🔄 初始化状态
        initial_state: CodingAgentState = {
            "requirements_doc": requirements_doc,
            "design_doc": design_doc,
            "project_name": project_name,
            "identified_services": [],
            "service_dependencies": {},
            "task_execution_plan": {},
            "parallel_tasks": [],
            "git_repo_url": None,
            "target_branch": f"feature/{project_name}",
            "project_paths": {},
            "repo_initialized": False,
            "generated_services": {},
            "generated_apis": {},
            "generated_sql": {},
            "service_interconnections": {},
            "unit_test_results": {},
            "test_coverage": {},
            "interface_compatibility": {},
            "code_review_results": {},
            "static_analysis_results": {},
            "security_scan_results": {},
            "commit_hashes": {},
            "push_results": {},
            "pr_urls": {},
            "current_phase": "task_splitting",
            "completed_services": [],
            "failed_services": [],
            "retry_count": 0,
            "execution_errors": []
        }
        
        # 🎯 执行工作流
        config = {
            "configurable": {
                "thread_id": f"coding_session_{project_name}_{int(time.time())}"
            }
        }
        
        try:
            # 🔄 运行编译后的图
            final_state = await self.compiled_graph.ainvoke(initial_state, config=config)
            
            # 📊 返回执行结果
            return {
                "status": "success",
                "project_name": project_name,
                "generated_services": final_state["generated_services"],
                "commit_hashes": final_state["commit_hashes"], 
                "pr_urls": final_state["pr_urls"],
                "execution_summary": self._generate_summary(final_state)
            }
            
        except Exception as e:
            self.logger.error(f"工作流执行失败: {e}")
            return {
                "status": "failed",
                "error": str(e),
                "project_name": project_name
            }
```

---

## 🧠 第二阶段：任务拆分节点实现

### 🎯 **task_splitting_node.py 实现提示词**

```python
"""
任务拆分节点 - 微服务架构分析和任务规划
核心功能：分析需求文档和设计文档，识别微服务边界，制定执行计划
"""

from ..agents.task_splitter_agent import TaskSplitterAgent
from ..prompts.task_splitting_prompts import TaskSplittingPrompts
from ..memory.task_memory import TaskMemory
from ..tools.task_tools import TaskAnalysisTools

async def task_splitting_node(state: CodingAgentState) -> CodingAgentState:
    """
    任务拆分节点 - 智能分析和规划
    
    输入：需求文档 + 设计文档
    输出：微服务列表 + 依赖关系 + 执行计划
    """
    
    # 🧠 初始化任务拆分智能体
    task_splitter = TaskSplitterAgent()
    
    # 📋 需求分析 - 从需求文档提取功能点
    requirements_analysis = await task_splitter.analyze_requirements(
        requirements_doc=state["requirements_doc"],
        prompt_template=TaskSplittingPrompts.REQUIREMENTS_ANALYSIS_PROMPT
    )
    
    # 🏗️ 设计分析 - 从设计文档识别架构
    design_analysis = await task_splitter.analyze_design(
        design_doc=state["design_doc"],
        prompt_template=TaskSplittingPrompts.DESIGN_ANALYSIS_PROMPT
    )
    
    # 🔍 微服务边界识别
    service_identification = await task_splitter.identify_microservices(
        requirements=requirements_analysis,
        design=design_analysis,
        prompt_template=TaskSplittingPrompts.SERVICE_BOUNDARY_PROMPT
    )
    
    # 🌐 服务依赖分析
    dependency_analysis = await task_splitter.analyze_dependencies(
        services=service_identification["services"],
        design_doc=state["design_doc"],
        prompt_template=TaskSplittingPrompts.DEPENDENCY_ANALYSIS_PROMPT
    )
    
    # 📅 执行计划制定
    execution_plan = await task_splitter.create_execution_plan(
        services=service_identification["services"],
        dependencies=dependency_analysis["dependencies"],
        complexity_scores=service_identification["complexity_scores"]
    )
    
    # 🔄 更新状态
    state["identified_services"] = service_identification["services"]
    state["service_dependencies"] = dependency_analysis["dependencies"]
    state["task_execution_plan"] = execution_plan
    state["parallel_tasks"] = execution_plan["parallel_batches"]
    state["current_phase"] = "git_management"
    
    # 💾 保存到任务记忆
    task_memory = TaskMemory()
    await task_memory.save_task_plan(state["project_name"], {
        "services": state["identified_services"],
        "dependencies": state["service_dependencies"],
        "execution_plan": state["task_execution_plan"]
    })
    
    return state
```

---

## 🔧 第三阶段：Git管理节点实现

### 🎯 **git_management_node.py 实现提示词**

```python
"""
Git管理节点 - 多仓库协调和分支管理
核心功能：解析设计文档中的Git地址，设置开发环境，创建功能分支
"""

from ..agents.git_manager_agent import GitManagerAgent
from ..mcp.git_mcp import GitMCP
from ..tools.git_tools import GitTools

async def git_management_node(state: CodingAgentState) -> CodingAgentState:
    """
    Git管理节点 - 环境准备和仓库管理
    
    功能：
    1. 从设计文档解析Git仓库地址
    2. 克隆/创建仓库，切换到功能分支
    3. 为每个微服务准备项目目录
    """
    
    # 🔧 初始化Git管理智能体
    git_manager = GitManagerAgent()
    git_mcp = GitMCP()
    
    try:
        # 🔍 从设计文档提取Git信息
        git_info = await git_manager.extract_git_info(
            design_doc=state["design_doc"],
            project_name=state["project_name"]
        )
        
        # 🌐 设置Git仓库
        if git_info["repo_url"]:
            # 现有仓库：克隆并切换分支
            repo_setup = await git_mcp.setup_existing_repository(
                repo_url=git_info["repo_url"],
                branch_name=state["target_branch"],
                local_path=f"./workspace/{state['project_name']}"
            )
        else:
            # 新仓库：初始化默认仓库
            repo_setup = await git_mcp.create_new_repository(
                project_name=state["project_name"],
                branch_name=state["target_branch"],
                template="springboot_microservices"
            )
        
        # 📁 为每个微服务创建项目目录
        project_paths = {}
        for service_name in state["identified_services"]:
            service_path = await git_mcp.create_service_directory(
                base_path=repo_setup["local_path"],
                service_name=service_name,
                template="springboot_service"
            )
            project_paths[service_name] = service_path
        
        # 🔄 更新状态
        state["git_repo_url"] = git_info["repo_url"]
        state["project_paths"] = project_paths
        state["repo_initialized"] = repo_setup["success"]
        state["current_phase"] = "intelligent_coding"
        
        if not repo_setup["success"]:
            state["execution_errors"].append(f"Git setup failed: {repo_setup['error']}")
            state["retry_count"] += 1
        
    except Exception as e:
        state["execution_errors"].append(f"Git management error: {str(e)}")
        state["repo_initialized"] = False
        state["retry_count"] += 1
    
    return state
```

---

## 💻 第四阶段：智能编码节点实现

### 🎯 **intelligent_coding_node.py 实现提示词**

```python
"""
智能编码节点 - 微服务代码生成
核心功能：并行生成SpringBoot微服务，处理服务间调用，生成SQL
技术栈：SpringBoot + Nacos + Java8 + MyBatis
"""

from ..agents.microservice_coding_agent import MicroserviceCodingAgent
from ..mcp.springboot_mcp import SpringBootMCP
from ..mcp.mybatis_mcp import MyBatisMCP
from ..mcp.maven_mcp import MavenMCP

async def intelligent_coding_node(state: CodingAgentState) -> CodingAgentState:
    """
    智能编码节点 - 微服务代码生成专家
    
    功能：
    1. 并行生成多个SpringBoot微服务
    2. 生成RESTful API和服务间调用
    3. 生成MyBatis Mapper和SQL语句
    4. 处理Nacos服务发现配置
    """
    
    # 🤖 初始化编码智能体和MCP工具
    coding_agent = MicroserviceCodingAgent()
    springboot_mcp = SpringBootMCP()
    mybatis_mcp = MyBatisMCP()
    maven_mcp = MavenMCP()
    
    # 📋 获取待处理的服务列表
    pending_services = [
        service for service in state["identified_services"] 
        if service not in state["completed_services"]
    ]
    
    # 🔄 并行处理服务（根据依赖关系）
    for batch in state["parallel_tasks"]:
        batch_services = [s for s in batch if s in pending_services]
        
        # 🚀 并发生成当前批次的服务
        batch_results = await asyncio.gather(*[
            generate_single_service(
                service_name=service,
                state=state,
                coding_agent=coding_agent,
                springboot_mcp=springboot_mcp,
                mybatis_mcp=mybatis_mcp,
                maven_mcp=maven_mcp
            ) for service in batch_services
        ])
        
        # 📊 更新状态
        for service, result in zip(batch_services, batch_results):
            if result["success"]:
                state["completed_services"].append(service)
                state["generated_services"][service] = result["generated_code"]
                state["generated_apis"][service] = result["api_endpoints"]
                state["generated_sql"][service] = result["sql_statements"]
            else:
                state["failed_services"].append(service)
                state["execution_errors"].append(f"{service}: {result['error']}")
    
    # 🌐 生成服务间调用代码
    if len(state["completed_services"]) > 1:
        interconnection_code = await coding_agent.generate_service_interconnections(
            services=state["completed_services"],
            dependencies=state["service_dependencies"],
            api_definitions=state["generated_apis"]
        )
        state["service_interconnections"] = interconnection_code
    
    state["current_phase"] = "code_review"
    return state

async def generate_single_service(
    service_name: str,
    state: CodingAgentState,
    coding_agent: MicroserviceCodingAgent,
    springboot_mcp: SpringBootMCP,
    mybatis_mcp: MyBatisMCP,
    maven_mcp: MavenMCP
) -> Dict[str, Any]:
    """生成单个微服务的完整代码"""
    
    try:
        service_path = state["project_paths"][service_name]
        
        # 🏗️ 1. 生成SpringBoot项目结构
        project_structure = await springboot_mcp.create_microservice_project(
            service_name=service_name,
            base_package=f"com.company.{service_name.replace('-', '')}",
            project_path=service_path,
            features=["web", "nacos-discovery", "mybatis-plus"]
        )
        
        # 📋 2. 分析服务需求
        service_requirements = await coding_agent.analyze_service_requirements(
            service_name=service_name,
            requirements_doc=state["requirements_doc"],
            design_doc=state["design_doc"]
        )
        
        # 🗄️ 3. 生成数据层（Entity + Mapper + SQL）
        data_layer = await mybatis_mcp.generate_data_layer(
            service_name=service_name,
            entities=service_requirements["entities"],
            project_path=service_path
        )
        
        # 🔧 4. 生成业务层（Service + ServiceImpl）
        business_layer = await coding_agent.generate_business_layer(
            service_name=service_name,
            business_logic=service_requirements["business_logic"],
            entities=service_requirements["entities"],
            project_path=service_path
        )
        
        # 🌐 5. 生成控制层（Controller + DTO）
        controller_layer = await coding_agent.generate_controller_layer(
            service_name=service_name,
            api_definitions=service_requirements["api_definitions"],
            project_path=service_path
        )
        
        # ⚙️ 6. 生成配置文件
        config_files = await springboot_mcp.generate_configuration(
            service_name=service_name,
            nacos_config={
                "server_addr": "127.0.0.1:8848",
                "namespace": "dev",
                "group": "DEFAULT_GROUP"
            },
            database_config=service_requirements["database_config"],
            project_path=service_path
        )
        
        # 📦 7. 配置Maven依赖
        maven_config = await maven_mcp.configure_dependencies(
            project_path=service_path,
            service_dependencies=state["service_dependencies"].get(service_name, []),
            tech_stack=["springboot", "nacos", "mybatis-plus", "mysql"]
        )
        
        return {
            "success": True,
            "generated_code": {
                "project_structure": project_structure,
                "data_layer": data_layer,
                "business_layer": business_layer,
                "controller_layer": controller_layer,
                "config_files": config_files,
                "maven_config": maven_config
            },
            "api_endpoints": controller_layer["api_endpoints"],
            "sql_statements": data_layer["sql_statements"]
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }
```

---

## 🧪 第五阶段：测试和提交节点

### 🎯 **unit_testing_node.py 实现提示词**

```python
"""
单元测试节点 - 测试生成和执行
核心功能：生成JUnit单元测试，执行测试，检查覆盖率
"""

async def unit_testing_node(state: CodingAgentState) -> CodingAgentState:
    """
    单元测试节点
    
    功能：
    1. 为每个微服务生成JUnit单元测试
    2. 生成Mock对象和测试数据
    3. 执行测试并收集覆盖率报告
    4. 检查服务间接口兼容性
    """
    
    # 🧪 初始化测试智能体
    test_agent = TestAgent()
    junit_mcp = JUnitMCP()
    
    # 🔄 为每个完成的服务生成测试
    for service_name in state["completed_services"]:
        service_code = state["generated_services"][service_name]
        
        # 📝 生成单元测试
        test_code = await test_agent.generate_unit_tests(
            service_name=service_name,
            service_code=service_code,
            test_strategy="comprehensive"  # 全面测试策略
        )
        
        # 🏃 执行测试
        test_results = await junit_mcp.run_tests(
            project_path=state["project_paths"][service_name],
            test_scope="unit"
        )
        
        state["unit_test_results"][service_name] = test_results
        state["test_coverage"][service_name] = test_results["coverage_percentage"]
    
    # 🔗 服务间接口兼容性检查
    compatibility_results = await test_agent.check_interface_compatibility(
        services=state["completed_services"],
        service_interconnections=state["service_interconnections"],
        api_definitions=state["generated_apis"]
    )
    
    state["interface_compatibility"] = compatibility_results
    state["current_phase"] = "git_commit"
    
    return state
```

### 🎯 **git_commit_node.py 实现提示词**

```python
"""
Git提交节点 - 代码提交和推送
核心功能：提交生成的代码，推送到远程仓库，创建PR
"""

async def git_commit_node(state: CodingAgentState) -> CodingAgentState:
    """
    Git提交节点
    
    功能：
    1. 提交各微服务的生成代码
    2. 推送到远程仓库
    3. 创建Pull Request
    """
    
    # 📤 初始化Git提交智能体
    git_commit_agent = GitCommitAgent()
    git_mcp = GitMCP()
    
    # 📝 为每个服务提交代码
    for service_name in state["completed_services"]:
        commit_message = await git_commit_agent.generate_commit_message(
            service_name=service_name,
            changes_summary=state["generated_services"][service_name],
            test_results=state["unit_test_results"][service_name]
        )
        
        # 💾 提交代码
        commit_result = await git_mcp.commit_service_changes(
            project_path=state["project_paths"][service_name],
            commit_message=commit_message,
            service_name=service_name
        )
        
        state["commit_hashes"][service_name] = commit_result["commit_hash"]
    
    # 🚀 推送到远程仓库
    push_result = await git_mcp.push_branch(
        branch_name=state["target_branch"],
        remote="origin"
    )
    
    # 📋 创建Pull Request
    if push_result["success"]:
        pr_result = await git_commit_agent.create_pull_request(
            branch_name=state["target_branch"],
            title=f"feat: {state['project_name']} - 微服务代码生成",
            description=git_commit_agent.generate_pr_description(state),
            reviewers=["tech-lead", "senior-dev"]
        )
        
        state["pr_urls"]["main"] = pr_result["pr_url"]
    
    state["current_phase"] = "completed"
    return state
```

---

## 📚 支撑组件提示词

### 🧠 **智能体基类实现**

```python
# src/corder_integration/agents/base/base_agent.py
"""
智能体基类 - 提供通用能力
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from ...memory.base_memory import BaseMemory
from ...mcp.mcp_manager import MCPManager

class BaseAgent(ABC):
    """智能体基类"""
    
    def __init__(self):
        self.memory = BaseMemory()
        self.mcp_manager = MCPManager()
        self.logger = logging.getLogger(self.__class__.__name__)
    
    @abstractmethod
    async def execute(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """执行智能体任务"""
        pass
    
    async def call_llm(self, prompt: str, context: Dict[str, Any]) -> str:
        """调用大模型"""
        # 实现LLM调用逻辑
        pass
    
    async def use_mcp_tool(self, tool_name: str, params: Dict[str, Any]) -> Any:
        """使用MCP工具"""
        return await self.mcp_manager.call_tool(tool_name, params)
```

### 🔧 **MCP工具管理器**

```python
# src/corder_integration/mcp/mcp_manager.py
"""
MCP工具管理器 - 统一管理所有MCP工具
"""

class MCPManager:
    """MCP工具统一管理器"""
    
    def __init__(self):
        self.tools = {
            "springboot": SpringBootMCP(),
            "mybatis": MyBatisMCP(), 
            "maven": MavenMCP(),
            "git": GitMCP(),
            "junit": JUnitMCP()
        }
    
    async def call_tool(self, tool_name: str, method: str, params: Dict[str, Any]) -> Any:
        """调用指定的MCP工具"""
        if tool_name not in self.tools:
            raise ValueError(f"Unknown MCP tool: {tool_name}")
        
        tool = self.tools[tool_name]
        method_func = getattr(tool, method)
        return await method_func(**params)
```

---

## 🚀 开发实施计划

### **第1步：建立LangGraph基础**
1. 实现 `workflow_orchestrator.py`
2. 定义 `CodingAgentState` 状态结构
3. 设置PostgreSQL检查点
4. 测试基本的LangGraph流程

### **第2步：任务拆分节点**
1. 实现 `task_splitting_node.py`
2. 创建 `TaskSplitterAgent`
3. 编写任务拆分提示词
4. 测试微服务识别和依赖分析

### **第3步：Git管理节点**
1. 实现 `git_management_node.py`
2. 创建 `GitManagerAgent`
3. 实现 `GitMCP` 工具
4. 测试仓库管理和分支操作

### **第4步：智能编码节点**
1. 实现 `intelligent_coding_node.py`
2. 创建 `MicroserviceCodingAgent`
3. 实现 SpringBoot、MyBatis、Maven MCP工具
4. 测试代码生成和服务互联

### **第5步：测试和提交节点**
1. 实现 `unit_testing_node.py` 和 `git_commit_node.py`
2. 创建测试和提交智能体
3. 端到端测试整个工作流
4. 优化错误处理和重试机制

### **第6天：集成和优化**
1. 集成现有的 `/process-document` API
2. 性能优化和并发处理
3. 添加监控和日志，使用当前项目框架的log
4. 完善错误恢复机制

---

## 🎯 关键实现要点

1. **状态驱动**：所有操作基于 `CodingAgentState` 状态
2. **检查点恢复**：利用PostgreSQL检查点实现断点续传
3. **并行处理**：支持多微服务并行生成
4. **依赖管理**：智能处理服务间依赖关系
5. **质量保证**：集成代码审查、测试、静态分析
6. **错误恢复**：完善的重试和回滚机制

从 `workflow_orchestrator.py` 开始实现，这将成为整个系统的控制中枢！

